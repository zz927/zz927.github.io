<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue的基本概念</title>
      <link href="/2018/10/13/Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/10/13/Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul><li><p>Vue.js是是一套用于构建用户界面的<strong>渐进式框架</strong>，是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p><a id="more"></a></li><li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</p></li><li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p></li></ul><h3 id="Vue的核心思想"><a href="#Vue的核心思想" class="headerlink" title="Vue的核心思想"></a>Vue的核心思想</h3><blockquote><ul><li>数据驱动，没有dom操作，页面显示由数据驱动</li><li>组件化，一个页面可以划分成很多组件</li><li>状态管理 ，vuex，可用于在多个页面之间进行数据共享</li></ul></blockquote><p>​    Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p><h3 id="1-1-5-MVC和MVVM"><a href="#1-1-5-MVC和MVVM" class="headerlink" title="1.1.5.MVC和MVVM"></a>1.1.5.MVC和MVVM</h3><h4 id="a-MVC"><a href="#a-MVC" class="headerlink" title="a) MVC"></a>a) MVC</h4><p>​    M - Model ：数据保存</p><p>​    V - View : 用户界面</p><p>​    C - Controller ： 业务逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户操作--&gt; View (负责接受用户的输入操作)--&gt;Controller（业务逻辑处理）--&gt;Model（数据持久化）--&gt;View（将结果通过View反馈给用户）</span><br></pre></td></tr></table></figure><p>​    MVC有两个很明显的问题：</p><p>​    1.m层和v层直接打交道，导致这两层耦合度高</p><p>​    2.因为所有逻辑都写在c层，导致c层特别臃肿</p><h4 id="b-MVVM"><a href="#b-MVVM" class="headerlink" title="b) MVVM"></a>b) MVVM</h4><p>​    前端应用的复杂程度已不同往日，暴露出了三个痛点问题：</p><p>　　1.开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。</p><p>　　2.大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p><p>　　3.当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</p><p>　　早期 jQuery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。</p><p>​    MVVM 的出现，完美解决了以上三个问题，MVVM 包含的三部分：</p><p>　　1.Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；</p><p>　　2.View 代表UI 组件，它负责将数据模型转化成UI 展现出来</p><p>　　3.ViewModel 是一个同步View 和 Model的对象。View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图：</p><p>​    MVVM 模式采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。angular 和vue都采用这种模式。</p><h4 id="c-前后端的MVC"><a href="#c-前后端的MVC" class="headerlink" title="c) 前后端的MVC"></a>c) 前后端的MVC</h4><p>​    一般情况下，后端的框架中多数采用MVC模式，比如structs2、springMVC、ASP.MVC、Express等</p><p>​    前端MVC大部分都是MVVM，包括angularJS、vue等。前后端分离的情况下，后端的MVC框架主要负责JSON数据的返回。</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li><p>.stop       阻止冒泡</p></li><li><p>.prevent    阻止默认事件</p></li><li><p>.capture    添加事件侦听器时使用事件捕获模式</p></li><li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once       事件只触发一次</p><h3 id="v-model和双向绑定"><a href="#v-model和双向绑定" class="headerlink" title="v-model和双向绑定"></a>v-model和双向绑定</h3><p>​    只有v-model指令实现了双向绑定， v-model 只能运用在表单元素中。如： input(radio, text, address, email….)   select    checkbox   textarea</p><h3 id="双向绑定的原理"><a href="#双向绑定的原理" class="headerlink" title="双向绑定的原理"></a>双向绑定的原理</h3><h4 id="页面–-gt-数据"><a href="#页面–-gt-数据" class="headerlink" title="页面–&gt;数据"></a>页面–&gt;数据</h4><p>​    view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现</p><h4 id="数据–-gt-页面"><a href="#数据–-gt-页面" class="headerlink" title="数据–&gt;页面"></a>数据–&gt;页面</h4><p>​    是通过数据劫持 + 发布者-订阅者模式的方式来实现的</p><h5 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h5><p>​    vue是通过Object.defineProperty()来实现数据劫持的</p><h5 id="数据绑定的实现流程"><a href="#数据绑定的实现流程" class="headerlink" title="数据绑定的实现流程"></a>数据绑定的实现流程</h5><p>​    首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。</p><p>​    因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</p><p>​    接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p><p>​    因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p><blockquote><p>1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。</p><p>2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者</p></blockquote></li></ul><h4 id="循环中key的使用"><a href="#循环中key的使用" class="headerlink" title="循环中key的使用"></a>循环中key的使用</h4><p>​    当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>​    为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p><h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><p>​    一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AMD和CMD</title>
      <link href="/2018/05/04/AMD%E5%92%8CCMD/"/>
      <url>/2018/05/04/AMD%E5%92%8CCMD/</url>
      
        <content type="html"><![CDATA[<h4 id="AMD模块规范"><a href="#AMD模块规范" class="headerlink" title="AMD模块规范"></a>AMD模块规范</h4><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AMD ： Asynchronous Module Definition。AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</span><br><span class="line">#1.定义</span><br><span class="line">define(id?,dependencies?,factory);</span><br><span class="line">    - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字.</span><br><span class="line">    - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量</span><br><span class="line">    - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值.</span><br><span class="line">    - 默认情况下文件名即为模块名</span><br><span class="line"></span><br><span class="line">#2.导入</span><br><span class="line"><span class="built_in">require</span>([dependencies],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">    - 第一个参数是一个数组,表示所依赖的模块</span><br><span class="line">    - 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块</span><br></pre></td></tr></table></figure><h4 id="CMD模块规范"><a href="#CMD模块规范" class="headerlink" title="CMD模块规范"></a>CMD模块规范</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMD 即Common Module Definition通用模块定义,CMD规范是国内发展出来的</span><br><span class="line"></span><br><span class="line">#1. 定义</span><br><span class="line">define(id?,d?,factory)</span><br><span class="line">- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id</span><br><span class="line">- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖</span><br><span class="line">- factory :函数   <span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span></span><br><span class="line"><span class="function">        <span class="title">require</span> 是一个方法,用来获取其他模块提供的接口</span></span><br><span class="line"><span class="function">        <span class="title">exports</span> 是一个对象,用来向外提供模块接口</span></span><br><span class="line"><span class="function">        <span class="title">module</span> 是一个对象,上面存储了与当前模块相关联的一些属性和方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#2. 使用</span></span><br><span class="line"><span class="function"><span class="title">seajs</span>.<span class="title">use</span>(<span class="params"><span class="string">'mymodel.js'</span>,function(mymodel</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="AMD和CMD区别"><a href="#AMD和CMD区别" class="headerlink" title="AMD和CMD区别"></a>AMD和CMD区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>CMD 推崇依赖就近;AMD 推崇依赖前置</span><br><span class="line"><span class="number">2.</span>CMD 是延迟执行,懒加载;AMD 是提前执行</span><br><span class="line"><span class="number">3.</span>CMD性能好,因为只有用户需要的时候才执行;AMD用户体验好,因为没有延迟,依赖模块提前执行了</span><br><span class="line"></span><br><span class="line"># 总结：AMD和CMD最大的区别是对依赖模块的执行时机处理不同,注意不是加载的时机或者方式不同。两者都是异步加载模块。</span><br><span class="line"></span><br><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">      a.doSomething()</span><br><span class="line">      b.dosomething()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> a=<span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">      a.doSomethimg()</span><br><span class="line">      <span class="keyword">var</span> b=<span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line">      b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP的一些用法</title>
      <link href="/2018/04/17/PHP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"/>
      <url>/2018/04/17/PHP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是PHP"><a href="#什么是PHP" class="headerlink" title="什么是PHP"></a>什么是PHP</h3><p>PHP（PHP: Hypertext Preprocessor）是一种被广泛应用的脚本语言，它可以被嵌入到 HTML中，尤其适合做动态网站开发开发。</p><a id="more"></a><p>​    我们接下来会在 PHP 中看到的许多代码特性和其他编程语言类似，例如：变量、函数、循环，等等。 代码语法看起来不同，但是在概念上是基本类似的。</p><h3 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a>PHP标记</h3><p>&lt;?php 可以让代码进入“PHP 模式”<br>?&gt; 可以让代码退出“PHP 模式”</p><h3 id="省略结束标记"><a href="#省略结束标记" class="headerlink" title="省略结束标记"></a>省略结束标记</h3><p>​    如果 PHP 代码段处于整个文件的末尾，建议（必须）删除结束标记，这样不会有额外的空行产生</p><h3 id="输出内容方式"><a href="#输出内容方式" class="headerlink" title="输出内容方式"></a>输出内容方式</h3><p>echo：</p><p>print：</p><p>var_dump：</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​    你可以在代码中添加注释，从而增强我们代码的可阅读性。PHP 中注释有两种方式（与 JavaScript 相同）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 单行注释</span><br><span class="line">&lt;?php</span><br><span class="line">// 这是一条单行注释</span><br><span class="line"># 井号也可以做注释（不要用，有点生僻）</span><br><span class="line">$foo = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 多行注释</span><br><span class="line">&lt;?php</span><br><span class="line">/*</span><br><span class="line">......</span><br><span class="line">这里可以添加任意行数的注释内容</span><br><span class="line">......</span><br><span class="line">*/</span><br><span class="line">$foo = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量 —— 用于临时存放数据的容器</span><br><span class="line">顺序结构 —— 先干什么再干什么</span><br><span class="line">分支结构 —— 如果怎样就怎样否则怎样</span><br><span class="line">循环结构 —— 不断的做某件相同的事</span><br><span class="line">函数 —— 提前设计好一件事怎么干，然后想什么时候干就什么时候干</span><br><span class="line">运算符 —— 数学运算和字符串拼接</span><br><span class="line">字面量 —— 在代码中用某些字符组成，能够表达一个具体的值 这些字符之间表示数据的方式叫做字面量</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    常见的 PHP 数据类型与 JavaScript 基本一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string（字符串）</span><br><span class="line">integer（整型）—— 只能存整数</span><br><span class="line">float（浮点型）—— 可以存带小数位的数字</span><br><span class="line">boolean（布尔型）</span><br><span class="line">array（数组）</span><br><span class="line">object（对象）</span><br><span class="line">NULL（空）</span><br><span class="line">Resource（资源类型）</span><br><span class="line">Callback / Callable（回调或者叫可调用类型）</span><br><span class="line"></span><br><span class="line">PHP 是一门弱类型语言，PHP会根据变量的值，自动把变量转换为正确的数据类型。</span><br><span class="line">在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​    变量是编程语言中临时存放数据的容器。</p><p>​    一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。变量名同样是区分大小写的。<br>    PHP 中变量无需声明类型，变量的类型根据值的类型来推断，PHP是弱类型的语言。</p><h3 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//PHP 有三种不同的变量作用域：</span><br><span class="line">local   局部</span><br><span class="line">global  全局</span><br><span class="line">static  静态</span><br></pre></td></tr></table></figure><h3 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h3><p>​    超全局变量是在全部作用域中始终可用的内置变量。PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。</p><p>​    这些超全局变量是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS — 引用全局作用域中可用的全部变量</span><br><span class="line">$_SERVER — 获取服务端相关信息</span><br><span class="line">$_REQUEST — 获取提交参数</span><br><span class="line">$_POST — 获取 POST 提交参数</span><br><span class="line">$_GET — 获取 GET 提交参数</span><br><span class="line">$_FILES — 获取上传文件</span><br><span class="line">$_ENV — 操作环境变量</span><br><span class="line">$_COOKIE — 操作 Cookie</span><br><span class="line">$_SESSION — 操作 Session</span><br></pre></td></tr></table></figure><h3 id="常量定义与使用"><a href="#常量定义与使用" class="headerlink" title="常量定义与使用"></a>常量定义与使用</h3><blockquote><p>常量跟变量一样也是一个数据容器，但是不同的是一旦申明过后就不允许被修改。</p></blockquote><h4 id="常量介绍"><a href="#常量介绍" class="headerlink" title="常量介绍"></a>常量介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常量就是恒定不变的量。</span><br><span class="line">常量的特点：</span><br><span class="line">1、常量前面没有美元符号($)</span><br><span class="line">2、常量可以不用理会变量的作用域在任何地方定义和访问</span><br><span class="line">3、常量一旦定义就不能重新定义或取消定义  unset()会报错</span><br><span class="line">4、常量的值只能是常量  &quot;a  &quot;abc&quot;  123</span><br></pre></td></tr></table></figure><h4 id="const和define区别："><a href="#const和define区别：" class="headerlink" title="const和define区别："></a>const和define区别：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、const可在类中使用，define不能</span><br><span class="line">2、define一般情况可以用来定义全局变量</span><br><span class="line">3、const不能再条件语句中定义常量，define可以</span><br><span class="line">4、define的值可以是任何表达式，const的值只可以是常量</span><br><span class="line">     define(&apos;BIT_5&apos;, 1 &lt;&lt; 5)</span><br></pre></td></tr></table></figure><h2 id="php面向对象"><a href="#php面向对象" class="headerlink" title="php面向对象"></a>php面向对象</h2><h3 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 面向对象的基本概念</span></span><br><span class="line">类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</span><br><span class="line"></span><br><span class="line">对象 − 是类的实例。</span><br><span class="line"></span><br><span class="line">成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</span><br><span class="line"></span><br><span class="line">成员函数 − 定义在类的内部，可用于访问对象的数据。</span><br><span class="line"></span><br><span class="line">继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</span><br><span class="line"></span><br><span class="line">父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</span><br><span class="line"></span><br><span class="line">子类 − 一个类继承其他类称为子类，也可称为派生类。</span><br><span class="line"></span><br><span class="line">多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</span><br><span class="line"></span><br><span class="line">抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</span><br><span class="line"></span><br><span class="line">封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</span><br><span class="line"></span><br><span class="line">构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与<span class="keyword">new</span>运算符一起使用在创建对象的语句中。</span><br><span class="line"></span><br><span class="line">析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做<span class="string">"清理善后"</span> 的工作（例如在建立对象时用<span class="keyword">new</span>开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</span><br></pre></td></tr></table></figure><h3 id="PHP重载"><a href="#PHP重载" class="headerlink" title="PHP重载"></a>PHP重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.php是弱类型语言，并没有像JAVA这种强类型语言一样有重载。</span><br><span class="line">2.在其他语言中，重载一般来说就是拥有相同的函数名或方法名，但是参数列表却不同(包括参数个数和参数类型)。</span><br><span class="line">3.在php中，重载一般用于对于当前对象的不可访问成员(私有的属性和方法)的处理。</span><br><span class="line">4.php通过魔术方法（magic methods __开头的方法）来实现重载，当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。</span><br><span class="line">5.魔法方法都是以public开头的</span><br><span class="line"></span><br><span class="line"># 魔法方法的介绍</span><br><span class="line">public function __set ($name,$value )</span><br><span class="line">public function __get ($name )</span><br><span class="line">public function __isset ($name )</span><br><span class="line">public function __unset ($name )</span><br><span class="line"></span><br><span class="line">在给不可访问的属性赋值时，__set() 会被调用。</span><br><span class="line">读取不可访问的属性的值时，__get()会被调用。</span><br><span class="line">当判断不可访问的属性是否存在的时候（使用isset()，empty()）时，__isset()会被调用。</span><br><span class="line">当对不可访问的属性执行销毁操作（unset()）的时候，__unset()会被调用。</span><br></pre></td></tr></table></figure><h3 id="命名空间介绍"><a href="#命名空间介绍" class="headerlink" title="命名空间介绍"></a>命名空间介绍</h3><p>​    命名空间将代码划分出不同的空间（区域），每个空间的常量、函数、类（为了偷懒，我下边都将它们称为元素）的名字互不影响， 这个有点类似java中的package。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//没有命名空间存在的问题：</span><br><span class="line">1.命名空间一个最明确的目的就是解决重名问题，PHP中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。这种情况下只要避免命名重复就可以解决，最常见的一种做法是约定一个前缀。</span><br><span class="line">2.比如：项目中有两个模块：article和message board，它们各自有一个处理用户留言的类Comment。这时候同时引入两个的Comment类显然是不行的，代码会出错。这时只能重构类名，我约定了一个命名规则，在类名前面加上模块名，像这样：Article_Comment、MessageBoard_Comment。但是这会导致命名过长的问题，解决方案就是使用命名空间。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2018/03/21/HTTP/"/>
      <url>/2018/03/21/HTTP/</url>
      
        <content type="html"><![CDATA[<h4 id="1-AJAX"><a href="#1-AJAX" class="headerlink" title="1.AJAX"></a>1.AJAX</h4><p>url：请求地址<br>type：请求方法，默认为 get<br>dataType：服务端响应数据类型</p><a id="more"></a><p>contentType：请求体内容类型，默认 application/x-www-form-urlencoded<br>data：需要传递到服务端的数据，如果 GET 则通过 URL 传递，如果 POST 则通过请求体传递<br>timeout：请求超时时间</p><p>beforeSend：请求发起之前触发<br>success：请求成功之后触发（响应状态码 200）<br>error：请求失败触发<br>complete：请求完成触发（不管成功与否）</p><h4 id="2-GET和POST的区别"><a href="#2-GET和POST的区别" class="headerlink" title="2.GET和POST的区别"></a>2.GET和POST的区别</h4><ul><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h4 id="3-Accept和Content-Type"><a href="#3-Accept和Content-Type" class="headerlink" title="3.Accept和Content-Type"></a>3.Accept和Content-Type</h4><p>Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。<br>服务器使用 Content-Type 应答头通知客户端它的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html</span><br><span class="line">Accept: image/*</span><br><span class="line">Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span><br></pre></td></tr></table></figure><p>1.Accept属于请求头， Content-Type属于实体头。 <br><br>Http报头分为通用报头，请求报头，响应报头和实体报头。 <br><br>请求方的http报头结构：通用报头|请求报头|实体报头 <br><br>响应方的http报头结构：通用报头|响应报头|实体报头<br></p><p>2.Accept代表发送端（客户端）希望接受的数据类型。 <br><br>比如：Accept：text/xml; <br><br>代表客户端希望接受的数据类型是xml类型<br></p><p>Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 <br><br>比如：Content-Type：text/html; <br><br>代表发送端发送的数据格式是html。<br></p><p>二者合起来， <br><br>Accept:text/xml； <br><br>Content-Type:text/html <br><br>即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。<br></p><h4 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4.状态码"></a>4.状态码</h4><table><thead><tr><th>状态码</th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>Informational（信息状态码）</td><td>接受请求正在处理</td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要附加操作已完成请求</td></tr><tr><td>4xx</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p>166、HTTP 状态消息 200 302 304 403 404 500 分别表示什么<br>200：请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>302：请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当<br>继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，<br>这个响应才是可缓存的<br>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上<br>次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁<br>止包含消息体，因此始终以消息头后的第一个空行结尾。<br>403：服务器已经理解请求，但是拒绝执行它。<br>404：请求失败，请求所希望得到的资源未被在服务器上发现。<br>500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这<br>个问题都会在服务器端的源代码出现错误时出现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型</title>
      <link href="/2018/02/16/JavaScript%E5%8E%9F%E5%9E%8B/"/>
      <url>/2018/02/16/JavaScript%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>​    什么是原型：原型是Javascript中的继承的基础，我们可以把一个函数的所有对象公共的属性和方法放入到函数的原型中。</p><a id="more"></a><h3 id="通过原型共享属性和方法"><a href="#通过原型共享属性和方法" class="headerlink" title="通过原型共享属性和方法"></a>通过原型共享属性和方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型来添加方法,解决数据共享,节省内存空间</span></span><br><span class="line">Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃凉菜"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.eat==p2.eat);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(p1);</span><br><span class="line"><span class="built_in">console</span>.dir(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么样子的数据是需要写在原型中?</span></span><br><span class="line"><span class="number">1.</span>需要共享的数据就可以写原型中，比如需要共享的属性和方法</span><br><span class="line"><span class="number">2.</span>不需要共享的数据写在构造函数中</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型的作用一:数据共享</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有学生的身高都是188,所有人的体重都是55</span></span><br><span class="line"><span class="comment">//所有学生都要每天写500行代码</span></span><br><span class="line"><span class="comment">//所有学生每天都要吃一个10斤的西瓜</span></span><br><span class="line"><span class="comment">//原型对象</span></span><br><span class="line">Student.prototype.height=<span class="string">"188"</span>;</span><br><span class="line">Student.prototype.weight=<span class="string">"55kg"</span>;</span><br><span class="line">Student.prototype.study=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"学习,写500行代码,小菜一碟"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Student.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"吃一个10斤的西瓜"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例化对象,并初始化</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"晨光"</span>,<span class="number">57</span>,<span class="string">"女"</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(Student);<span class="comment">//可以看到Student函数中有一个prototype，prototype中存放了我们所定义的若干方法</span></span><br><span class="line"><span class="built_in">console</span>.dir(stu);<span class="comment">//可以看到stu的__proto__实际就是Student.prototype</span></span><br></pre></td></tr></table></figure><h3 id="原型-prototype和-proto"><a href="#原型-prototype和-proto" class="headerlink" title="原型: prototype和 proto "></a>原型: prototype和<strong> proto </strong></h3><p>​    实例对象中有<strong> proto </strong>这个属性,指向函数的原型,是一个对象,这个属性是给浏览器使用,不是标准的属性<br>    构造函数中有prototype这个属性,叫函数的原型,是一个对象,这个属性是给程序员使用,是标准的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name=name;</span><br><span class="line">     <span class="keyword">this</span>.age=age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//通过原型来添加方法,解决数据共享,节省内存空间</span></span><br><span class="line">   Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"吃凉菜"</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line">   <span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.dir(p1);</span><br><span class="line">   <span class="built_in">console</span>.dir(p2);</span><br><span class="line">   <span class="built_in">console</span>.dir(Person);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(p1.__proto__==Person.prototype); <span class="comment">//true</span></span><br><span class="line">   p1.__proto__.eat();</span><br></pre></td></tr></table></figure><h3 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h3><p>​    1. 任何函数都具有一个    <code>prototype</code> 属性，该属性是一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2. 构造函数的 <code>prototype 对象默认都有一个</code>constructor<code>属性，指向</code>prototype对象所在函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.prototype.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>​    3. 通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__.constructor==F);</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__.constructor === F.prototype.constructor) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>​    4.总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 任何函数都具有一个 prototype 属性，该属性是一个对象</span><br><span class="line">2) 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数</span><br><span class="line">3) 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__</span><br><span class="line">4) 所有实例都直接或间接继承了原型对象的成员</span><br><span class="line">5) 构造函数的原型对象(prototype)中的属性和方法是可以被实例对象直接访问的</span><br></pre></td></tr></table></figure><h3 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h3><p>​    我们注意到，前面例子中每添加一个属性和方法就要敲一遍     <code>Person.prototype</code> 。<br>    为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Person~~~hi!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这样修改完之后，Person的原型中只有type和sayHello信息，把之前的sayHi以及constructor给丢失了*/</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  type: <span class="string">'human'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在该示例中，我们将   <code>Person.prototype</code> 重置到了一个新的对象。<br>    这样做的好处就是为   <code>Person.prototype</code> 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 <code>constructor</code> 成员(其实我们不写的时候会把constructor设置为Object的构造器)。</p><p>​    所以，我们为了保持   <code>constructor</code> 的指向正确，建议的写法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Person~~~hi!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // =&gt; 手动将 <span class="keyword">constructor</span> 指向正确的构造函数</span><br><span class="line">  type: 'human',</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Person~~~hi!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型方法的互相访问"><a href="#原型方法的互相访问" class="headerlink" title="原型方法的互相访问"></a>原型方法的互相访问</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型对象中的方法,可以相互调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型中添加方法</span></span><br><span class="line">Animal.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"动物吃东西"</span>);</span><br><span class="line">    <span class="keyword">this</span>.play();</span><br><span class="line">&#125;;</span><br><span class="line">Animal.prototype.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"玩球"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sleep();</span><br><span class="line">&#125;;</span><br><span class="line">Animal.prototype.sleep=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"睡觉了"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">"小苏"</span>,<span class="number">20</span>);</span><br><span class="line">dog.eat();</span><br></pre></td></tr></table></figure><h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>​    所有函数都有 prototype 属性对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Object.prototype</span><br><span class="line">2. Function.prototype</span><br><span class="line">3. Array.prototype</span><br><span class="line">4. String.prototype</span><br><span class="line">5. Number.prototype</span><br><span class="line">6. Date.prototype</span><br><span class="line">7. ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件</title>
      <link href="/2017/12/27/JavaScript%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/12/27/JavaScript%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="addEventListener和attachEvent区别"><a href="#addEventListener和attachEvent区别" class="headerlink" title="addEventListener和attachEvent区别"></a>addEventListener和attachEvent区别</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同点: 都可以为元素绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不同点:</span></span><br><span class="line">* <span class="number">1.</span>方法名不一样</span><br><span class="line">* <span class="number">2.</span>参数个数不一样addEventListener三个参数,attachEvent两个参数</span><br><span class="line">* <span class="number">3.</span>addEventListener 谷歌,火狐,IE11支持,IE8不支持</span><br><span class="line">*   attachEvent 谷歌火狐不支持,IE11不支持,IE8支持</span><br><span class="line">* <span class="number">4.</span><span class="keyword">this</span>不同,addEventListener 中的<span class="keyword">this</span>是当前绑定事件的对象</span><br><span class="line">*   attachEvent中的<span class="keyword">this</span>是<span class="built_in">window</span>。(IE8中其实通过apply、call改变了<span class="keyword">this</span>的指向)</span><br><span class="line">* <span class="number">5.</span>addEventListener中事件的类型(事件的名字)没有on</span><br><span class="line">*   attachEvent中的事件的类型(事件的名字)有on</span><br></pre></td></tr></table></figure><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。 每一个事件的生成都有一个event对象，这个对象中包含该事件的类型、触发者、触发位置等信息</p><ul><li>event.type 获取事件类型</li><li>event.target || event.srcElement 用于获取触发事件的元素</li><li>clientX/clientY     所有浏览器都支持，可视区位置</li><li>pageX/pageY       IE8以前不支持，页面位置</li><li>event.preventDefault() 取消默认行为</li><li>event.stopPropagation() 阻止事件传播</li><li>获取键盘按键信息</li></ul><h4 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h4><ul><li>事件源 : 触发(被)事件的元素</li><li>事件类型 : 事件的触发方式(例如鼠标点击或键盘点击)</li><li>事件处理程序 : 事件触发后要执行的代码(函数形式)</li></ul><h4 id="event对象的获取"><a href="#event对象的获取" class="headerlink" title="event对象的获取"></a>event对象的获取</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件参数e在IE8的浏览器中是不存在,此时用window.event来代替</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//兼容性写法：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="event-type的使用"><a href="#event-type的使用" class="headerlink" title="event.type的使用"></a>event.type的使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"呵呵"</span> id=<span class="string">"btn"</span>/&gt;</span><br><span class="line"></span><br><span class="line">my$(<span class="string">"btn"</span>).onclick = f1;</span><br><span class="line">my$(<span class="string">"btn"</span>).onmouseover = f1;</span><br><span class="line">my$(<span class="string">"btn"</span>).onmouseout = f1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">alert(<span class="string">"好帅哦"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line"><span class="keyword">this</span>.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line"><span class="keyword">this</span>.style.backgroundColor = <span class="string">"green"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻止事件传播的方式"><a href="#阻止事件传播的方式" class="headerlink" title="阻止事件传播的方式"></a>阻止事件传播的方式</h4><p>​        事件传递 : 多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发了,外面的元素的该事件自动的触发了。</p><h5 id="为什么有事件传播："><a href="#为什么有事件传播：" class="headerlink" title="为什么有事件传播："></a>为什么有事件传播：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//事件可以分为三个阶段</span><br><span class="line">* 1.事件捕获阶段  : 从外向内</span><br><span class="line">* 2.事件目标阶段  : 最开始选择的那个</span><br><span class="line">* 3.事件冒泡阶段  : 从里向外</span><br><span class="line"></span><br><span class="line">//为元素绑定事件</span><br><span class="line">* addEventListener(&quot;没有on的事件类型&quot;,事件处理函数,控制事件阶段的)</span><br><span class="line"></span><br><span class="line">//addEventListener中第三个参数是控制事件阶段的</span><br><span class="line">* 通过e.eventPhase这个属性可以知道当前的事件是什么阶段</span><br><span class="line"></span><br><span class="line">//如果e.eventPhase这个属性的值是:</span><br><span class="line">* 1----&gt;捕获阶段</span><br><span class="line">* 2----&gt;目标阶段</span><br><span class="line">* 3----&gt;冒泡</span><br><span class="line"></span><br><span class="line">//一般默认都是冒泡阶段,很少用捕获阶段</span><br><span class="line">* 捕获阶段:从外向内</span><br><span class="line">* 冒泡阶段:从里向外</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"dv1"</span>&gt;</span><br><span class="line">  &lt;div id=<span class="string">"dv2"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"dv3"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//事件冒泡:是从里向外</span></span><br><span class="line">  <span class="comment">//同时注册点击事件</span></span><br><span class="line">  <span class="keyword">var</span> objs = [my$(<span class="string">"dv3"</span>), my$(<span class="string">"dv2"</span>), my$(<span class="string">"dv1"</span>)];</span><br><span class="line">  <span class="comment">//遍历注册事件</span></span><br><span class="line">  objs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//为每个元素绑定事件</span></span><br><span class="line">    ele.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.id+<span class="string">"====&gt;"</span>+e.eventPhase);</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在addEventListener函数最后一个参数是true或者false情况下，我们可以看到打印结果的变化</span></span><br></pre></td></tr></table></figure><h5 id="如何阻止事件传播"><a href="#如何阻止事件传播" class="headerlink" title="如何阻止事件传播"></a>如何阻止事件传播</h5><ul><li>标准方式 event.stopPropagation();  谷歌和火狐支持</li><li>event.cancelBubble = true; 标准中已废弃   IE特有的,谷歌支持,火狐不支持</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"fun1"</span>);</span><br><span class="line"><span class="comment">//w3c标准</span></span><br><span class="line"><span class="keyword">if</span>(e&amp;&amp;e.stopPropagation)&#123;</span><br><span class="line">e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ie</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h4><p>非IE    e.preventDefault()</p><p>IE        event.returnValue = true;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.baidu.com"</span> onclick=<span class="string">"fn(event)"</span>&gt;点击我吧&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">function fn(e)&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/查看e是否存在preventDefault方法</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/火狐浏览器(w3c标准)</span></span><br><span class="line"><span class="regexp">if(e&amp;&amp;e.preventDefault)&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/阻止默认行为</span></span><br><span class="line"><span class="regexp">e.preventDefault();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ie浏览器(后期版本的ie也遵从了w3c规范)</span></span><br><span class="line"><span class="regexp">else&#123;</span></span><br><span class="line"><span class="regexp">window.event.returnValue = true;</span></span><br><span class="line"><span class="regexp">         return false;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h4><h5 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h5><p>​    代理是一种常用的设计模式，代理模式可以对原有的类进行扩展，即通过代理对象的模式来访问目标类。最通俗的例子就是假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的。明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子。</p><p>​    代理的好处：</p><p>​    1.限制对象的访问权限</p><p>​    2.在不改变目标对象代码的基础上为它动态的添加功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.talkBusiness = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"谈了1个亿的生意"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Agent</span>(<span class="params">name,p</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.p = p;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.talkBusiness = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//目标对象的目标方法之前做的事情</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"谈生意之前制定计划"</span>);</span><br><span class="line"> <span class="comment">//目标对象调用目标方法</span></span><br><span class="line"> <span class="keyword">this</span>.p.talkBusiness();</span><br><span class="line"> <span class="comment">//目标对象的目标方法之后做的事情</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"谈生意之后做总结"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//目标对象</span></span><br><span class="line"> <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"成龙"</span>);</span><br><span class="line"> <span class="comment">//代理对象</span></span><br><span class="line"> <span class="keyword">var</span> a = <span class="keyword">new</span> Agent(<span class="string">"华谊传媒"</span>,p);</span><br><span class="line"> a.talkBusiness();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的组成</title>
      <link href="/2017/12/18/JavaScript%E7%9A%84%E7%BB%84%E6%88%90/"/>
      <url>/2017/12/18/JavaScript%E7%9A%84%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><p>JavaScript=ECMAScript+DOM+BOM</p><a id="more"></a><h4 id="ECMAScript-JavaScript的核心"><a href="#ECMAScript-JavaScript的核心" class="headerlink" title="ECMAScript - JavaScript的核心"></a>ECMAScript - JavaScript的核心</h4><p>​    定义了javascript的语法规范</p><p>​    JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p><h4 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM - 浏览器对象模型"></a>BOM - 浏览器对象模型</h4><p>​    一套操作浏览器功能的API</p><p>​    通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p><h4 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM - 文档对象模型"></a>DOM - 文档对象模型</h4><p>​    一套操作页面元素的API</p><p>​    DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM的概念"><a href="#DOM的概念" class="headerlink" title="DOM的概念"></a>DOM的概念</h3><p>​    文档对象模型（Document Object Model，简称DOM），是<a href="http://baike.baidu.com/item/W3C" target="_blank" rel="noopener">W3C</a>组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。</p><p>​    Document Object Model的历史可以追溯至1990年代后期微软与<a href="http://baike.baidu.com/item/Netscape" target="_blank" rel="noopener">Netscape</a>的“浏览器大战”，双方为了在<a href="http://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a>与<a href="http://baike.baidu.com/item/JScript" target="_blank" rel="noopener">JScript</a>一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有<a href="http://baike.baidu.com/item/VBScript" target="_blank" rel="noopener">VBScript</a>、<a href="http://baike.baidu.com/item/ActiveX" target="_blank" rel="noopener">ActiveX</a>、以及微软自家的<a href="http://baike.baidu.com/item/DHTML" target="_blank" rel="noopener">DHTML</a>格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。</p><p>​    DOM又称为文档树模型</p><ul><li><p>文档：一个网页可以称为文档</p></li><li><p>节点：网页中的所有内容都是节点（标签、属性、文本、注释等）</p></li><li><p>元素：网页中的标签</p></li><li><p>属性：标签的属性</p><h3 id="DOM可以做什么"><a href="#DOM可以做什么" class="headerlink" title="DOM可以做什么"></a>DOM可以做什么</h3><ul><li>获取元素</li><li>动态创建元素</li><li>对元素进行操作(设置其属性或调用其方法)</li><li>事件(什么时机做相应的操作)</li></ul><h3 id="添加事件的三种方式"><a href="#添加事件的三种方式" class="headerlink" title="添加事件的三种方式"></a>添加事件的三种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1.初级方案</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; onclick=&quot;alert(&apos;我被点了&apos;)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">//2.中级方案</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function f1() &#123;</span><br><span class="line">    alert(&quot;这是一个对话框&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; onclick=&quot;f1()&quot;/&gt;</span><br><span class="line"></span><br><span class="line">//3.最终方案：使用dom对象进行事件分配</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;开始分离代码&quot; id=&quot;btn1&quot; /&gt;</span><br><span class="line">//  //根据id属性的值从整个文档中获取这个元素(标签)</span><br><span class="line">var btnObj1=document.getElementById(&quot;btn1&quot;);</span><br><span class="line">  //为该元素注册点击事件</span><br><span class="line">btnObj1.onclick=function () &#123;</span><br><span class="line">    alert(&quot;哦,这真是太好了&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//根据id属性的值从整个文档中获取这个元素(标签)</span><br><span class="line">//为该元素注册点击事件</span><br><span class="line">document.getElementById(&quot;btn1&quot;).onclick=function () &#123;</span><br><span class="line">  alert(&quot;哦,这真是太好了&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//注意  : &lt;script&gt;标签在body前后位置带来的影响</span><br></pre></td></tr></table></figure><h2 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h2><h3 id="根据id获取元素"><a href="#根据id获取元素" class="headerlink" title="根据id获取元素"></a>根据id获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到的数据类型 HTMLDivElement，对象都是有类型的</span></span><br><span class="line"><span class="comment">// HTMLDivElement &lt;-- HTMLElement &lt;-- Element  &lt;-- Node  &lt;-- EventTarget</span></span><br></pre></td></tr></table></figure><p>​    注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。</p><h3 id="根据标签名获取元素"><a href="#根据标签名获取元素" class="headerlink" title="根据标签名获取元素"></a>根据标签名获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = divs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据name获取元素"><a href="#根据name获取元素" class="headerlink" title="根据name获取元素"></a>根据name获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputs = <span class="built_in">document</span>.getElementsByName(<span class="string">'hobby'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; inputs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> input = inputs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据类名获取元素"><a href="#根据类名获取元素" class="headerlink" title="根据类名获取元素"></a>根据类名获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h5，IE9之后支持</span></span><br><span class="line"><span class="keyword">var</span> mains = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mains.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> main = mains[i];</span><br><span class="line">  <span class="built_in">console</span>.log(main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据选择器获取元素"><a href="#根据选择器获取元素" class="headerlink" title="根据选择器获取元素"></a>根据选择器获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">'#text'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boxes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.box'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; boxes.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> box = boxes[i];</span><br><span class="line">  <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getElementsByTagName和querySelector的区别"><a href="#getElementsByTagName和querySelector的区别" class="headerlink" title="getElementsByTagName和querySelector的区别"></a>getElementsByTagName和querySelector的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.区别</span></span><br><span class="line">getElementsByTagName获取的是动态集合，querySelector获取的是静态集合。</span><br><span class="line">简单的说就是，动态就是选出的元素会随文档改变，静态的不会，取出来之后就和文档的改变无关了。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.应用场景</span></span><br><span class="line">如果只要一次查找就可得到元素时，首选querySelector ；</span><br><span class="line">如果需要经过多级查找，才能得到元素时，用getElementsByTagName；</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;aaa&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;ddd&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;ccc&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>];</span><br><span class="line">    lis = ul.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log( lis.length);  <span class="comment">//4</span></span><br><span class="line">&lt;<span class="regexp">/script&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    var ul = document.getElementsByTagName('ul')[0];</span></span><br><span class="line"><span class="string">    var lis = document.querySelectorAll('li');</span></span><br><span class="line"><span class="string">    ul.appendChild(document.createElement("</span>li<span class="string">"));</span></span><br><span class="line"><span class="string">    console.log( lis.length);  //3</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id属性的值获取元素,返回来的是一个元素对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementById(<span class="string">"id属性的值"</span>);</span><br><span class="line"><span class="comment">//根据标签名字获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementsByTagName(<span class="string">"标签名字"</span>);</span><br><span class="line"><span class="comment">//下面的几个,有的浏览器不支持</span></span><br><span class="line"><span class="comment">//根据name属性的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementsByName(<span class="string">"name属性的值"</span>)</span><br><span class="line"><span class="comment">//根据类样式的名字来获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementsByClassName(<span class="string">"类样式的名字"</span>)</span><br><span class="line"><span class="comment">//根据选择器获取元素,返回来的是一个元素对象</span></span><br><span class="line">* <span class="built_in">document</span>.querySelector(<span class="string">"选择器的名字"</span>);</span><br><span class="line"><span class="comment">//根据选择器获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.querySelectorAll(<span class="string">"选择器的名字"</span>)</span><br></pre></td></tr></table></figure><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><h3 id="非表单元素的属性"><a href="#非表单元素的属性" class="headerlink" title="非表单元素的属性"></a>非表单元素的属性</h3><ul><li>href、title、id、src</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.baidu.com"</span> title=<span class="string">"baidu"</span> id=<span class="string">"link"</span>&gt;点我&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var link = document.getElementById('link');</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/通过console.dir(link) 可以查看该a节点对象的所有信息</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/通过打印我们发现除了title和href属性之外，document文档对象模型还帮我们封装了其他很多属性</span></span><br><span class="line"><span class="regexp">console.dir(link);</span></span><br><span class="line"><span class="regexp">console.log(link.href);</span></span><br><span class="line"><span class="regexp">console.log(link.title);</span></span><br><span class="line"><span class="regexp">console.log(link.host);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var pic = document.getElementById('pic');</span></span><br><span class="line"><span class="regexp">console.log(pic.src);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/我们也可以直接通过link.href = "xx"来给属性赋值</span></span><br></pre></td></tr></table></figure><ul><li>innerText/textContent/innerHTML/value</li></ul><p>​       a) textContent和innerText的区别</p><p>​          textContent : 设置标签中的文本内容,谷歌,火狐支持,IE8不支持</p><pre><code>innerText : 设置标签中的文本内容,谷歌,火狐,IE8都支持</code></pre><p>​           如果这个属性在浏览器中不支持,那么这个属性的类型是undefined，所以判断这个属性的类型是不是    undefined,就知道浏览器是否支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置任意的标签中间的任意文本内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element,text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断浏览器是否支持这个属性</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> element.textContent ==<span class="string">"undefined"</span>)&#123;</span><br><span class="line">      <span class="comment">//不支持</span></span><br><span class="line">      element.innerText=text;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//支持这个属性</span></span><br><span class="line">      element.textContent=text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取任意标签中间的文本内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> element.textContent==<span class="string">"undefined"</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> element.innerText;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> element.textContent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    b) innerText和innerHTML的区别</p><p>​           如果使用innerText主要是设置和获取文本的,设置标签内容,是没有标签的效果的</p><pre><code>innerHTML主要的作用是在标签中设置新的html或者获取html标签内容,是有标签效果的</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my$(<span class="string">"btn"</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   my$(<span class="string">"dv"</span>).innerText=<span class="string">"哈哈"</span>;<span class="comment">//设置文本</span></span><br><span class="line">   my$(<span class="string">"dv"</span>).innerText=<span class="string">"&lt;p&gt;这是一个p&lt;/p&gt;"</span>;<span class="comment">//设置html标签的代码</span></span><br><span class="line"></span><br><span class="line">   my$(<span class="string">"dv"</span>).innerHTML=<span class="string">"哈哈"</span>;</span><br><span class="line">   my$(<span class="string">"dv"</span>).innerHTML=<span class="string">"&lt;p&gt;这是一个p&lt;/p&gt;"</span>;<span class="comment">//设置Html标签的</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取</span></span><br><span class="line"> my$(<span class="string">"btn2"</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//可以获取标签中的文本内容</span></span><br><span class="line">   <span class="built_in">console</span>.log(my$(<span class="string">"dv"</span>).innerText);</span><br><span class="line">   <span class="built_in">console</span>.log(my$(<span class="string">"dv"</span>).innerHTML);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>​    c)  value : 主要是用来给value属性赋值</p><ul><li>类名操作 : 修改标签的className属性相当于直接修改标签的类名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.className = <span class="string">'clearfix'</span>;</span><br></pre></td></tr></table></figure><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、获取行内（内嵌、行间）样式：</span></span><br><span class="line">    obj.style.attr;进行获取非行间样式。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、设置行内样式：</span></span><br><span class="line">    obj.style.attr = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、举例：</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.style.width = <span class="string">'100px'</span>;</span><br><span class="line">box.style.height = <span class="string">'100px'</span>;</span><br><span class="line">box.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line"><span class="comment">//通过样式属性设置宽高、位置的属性类型是字符串，需要加上px</span></span><br></pre></td></tr></table></figure></li></ul><p>节点介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">节点(Node)的分类：</span><br><span class="line">文档节点  Document</span><br><span class="line">元素节点  Element  指的是页面中的标签</span><br><span class="line">属性节点  Attr</span><br><span class="line">文本节点  Text</span><br><span class="line"></span><br><span class="line">节点的属性：</span><br><span class="line">nodeType ： 1--&gt;标签，2--&gt;属性,3--&gt;文本</span><br><span class="line">nodeName ： 标签--&gt;标签名，属性--&gt;属性名，文本--&gt;#text</span><br><span class="line">nodeValue : 标签--&gt;null，属性--&gt;属性值，文本--&gt;文本内容</span><br><span class="line"></span><br><span class="line">节点层次的属性</span><br><span class="line">parentNode    ---父节点</span><br><span class="line">    parentElement  ---父元素(结果和parentNode一样)</span><br><span class="line">childNodes    ---所有子节点，包含文本节点</span><br><span class="line">children      -- 所有子元素</span><br><span class="line">nextSibling/previousSibling   --前一个子节点(包含文本节点),IE8中获取第一个子元素</span><br><span class="line">    nextElementSibling/previousElementSibling   --前一个子元素，IE8中不支持</span><br><span class="line">firstChild/lastChild   --获取第一个子节点，IE8中是第一个子元素</span><br><span class="line">    firstElementChild      --获取第一个子元素，IE8中不支持</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-对象</title>
      <link href="/2017/10/13/JavaScript-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/10/13/JavaScript-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>面向过程：关注的是问题解决的步骤，注重过程<br>面向对象：关注的是问题解决的主体，注重结果    </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。</span><br><span class="line">举例： 一部车，一个手机</span><br><span class="line">车是一类事物，门口停的那辆车才是对象</span><br><span class="line">特征：红色、四个轮子</span><br><span class="line">行为：驾驶、刹车</span><br></pre></td></tr></table></figure><h3 id="JavaScript中的对象"><a href="#JavaScript中的对象" class="headerlink" title="JavaScript中的对象"></a>JavaScript中的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript中的对象其实就是生活中对象的一个抽象</span><br><span class="line">JavaScript的对象是无序属性的集合。</span><br><span class="line">其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。</span><br><span class="line">对象的行为和特征</span><br><span class="line">特征---属性</span><br><span class="line">行为---方法</span><br></pre></td></tr></table></figure><ul><li>事物的特征在对象中用属性来表示。</li><li>事物的行为在对象中用方法来表示。</li></ul><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>对象字面量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="literal">true</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//其实这种方法内部会自动调用new Object()方法来创建对象</span></span><br></pre></td></tr></table></figure><ul><li>new Object()创建对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'lisi'</span>;</span><br><span class="line">person.age = <span class="number">35</span>;</span><br><span class="line">person.job = <span class="string">'actor'</span>;</span><br><span class="line">person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,everyBody'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：每创建一个对象都要写一堆代码，太麻烦</span></span><br></pre></td></tr></table></figure><ul><li>工厂函数创建对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  person.name = name;</span><br><span class="line">  person.age = age;</span><br><span class="line">  person.job = job;</span><br><span class="line">  person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,everyBody'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'张三'</span>, <span class="number">22</span>, <span class="string">'actor'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：无法判断所创建出来的对象的具体类型  instanceof</span></span><br></pre></td></tr></table></figure><ul><li>自定义构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello,everyBody'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>, <span class="number">22</span>, <span class="string">'actor'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好处：既封装了内部实现，又能通过instanceof来判断所创建出来对象的具体类型</span></span><br></pre></td></tr></table></figure><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征</span><br><span class="line">如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能</span><br></pre></td></tr></table></figure><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><blockquote><p>构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p></blockquote><ol><li>构造函数用于创建一类对象，首字母要大写。</li><li>构造函数要和new一起使用才有意义。</li></ol><p>new在执行时会做四件事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 会在内存中创建一个新的空对象</span><br><span class="line">new 会让this指向这个新的对象</span><br><span class="line">执行构造函数  目的：给这个新对象加属性和方法</span><br><span class="line">new会返回这个新对象</span><br></pre></td></tr></table></figure><h3 id="设置和获取属性的另一种写法"><a href="#设置和获取属性的另一种写法" class="headerlink" title="设置和获取属性的另一种写法"></a>设置和获取属性的另一种写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"喜欢玩游戏"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">"卡卡西"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//obj.name="佐助";</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">"name"</span>]=<span class="string">"佐助"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line">obj.play();</span><br><span class="line">obj[<span class="string">"play"</span>]();</span><br></pre></td></tr></table></figure><h3 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h3><blockquote><p>通过for..in语法可以遍历一个对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  obj[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="comment">//因为此时遍历到的key是一个字符串，需要通过obj[key]的方式才能访问内容</span></span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">"=="</span> + obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'mm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fun(); </span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// mm </span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="简单类型和复杂类型的区别"><a href="#简单类型和复杂类型的区别" class="headerlink" title="简单类型和复杂类型的区别"></a>简单类型和复杂类型的区别</h3><p>浅谈js内存：<a href="https://www.jianshu.com/p/396c110378db" target="_blank" rel="noopener">https://www.jianshu.com/p/396c110378db</a></p><blockquote><p>基本类型又叫做值类型，复杂类型又叫做引用类型</p><p>值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。</p><p>引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。</p></blockquote><ul><li><p>堆和栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆栈空间分配区别：</span><br><span class="line">　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</span><br><span class="line">　　2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-预解析</title>
      <link href="/2017/09/30/JavaScript-%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/09/30/JavaScript-%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote><p>JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程</p><a id="more"></a></blockquote><p>预解析过程：</p><ol><li>把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。</li><li>把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</li><li>函数声明和变量声明都会置顶，但是变量声明位于函数声明之后</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 1、变量的提升</span><br><span class="line"></span><br><span class="line">var num = 10;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line">function fun() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(num);</span><br><span class="line"></span><br><span class="line">  var num = 20;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、函数的提升</span><br><span class="line"></span><br><span class="line">var a = 18;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">function f1() &#123;</span><br><span class="line"></span><br><span class="line">  var b = 9;</span><br><span class="line"></span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line">  console.log(b);</span><br><span class="line"></span><br><span class="line">  var a = &apos;123&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//隐式全局变量的注意点</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line">console.log(c);</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line"></span><br><span class="line">  var a = b = c = 9;</span><br><span class="line"></span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line">  console.log(b);</span><br><span class="line"></span><br><span class="line">  console.log(c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等效于</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line"></span><br><span class="line">  var a;  //局部变量</span><br><span class="line"></span><br><span class="line">  a = 9;  </span><br><span class="line"></span><br><span class="line">  b = 9;  //隐式全局变量</span><br><span class="line"></span><br><span class="line">  c = 9;  //隐式全局变量</span><br><span class="line"></span><br><span class="line">  console.log(a);  //9</span><br><span class="line"></span><br><span class="line">  console.log(b);  //9</span><br><span class="line"></span><br><span class="line">  console.log(c);  //9</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line">console.log(c);  //9</span><br><span class="line"></span><br><span class="line">console.log(b);  //9</span><br><span class="line"></span><br><span class="line">console.log(a);  //undefined   因为a是局部变量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//隐式全局变量的进一步说明</span><br><span class="line">var a = 18;</span><br><span class="line">b = 10;</span><br><span class="line">console.log(b);</span><br><span class="line"></span><br><span class="line">delete b;</span><br><span class="line">console.log(b);   //此处会报错，原因隐式全局变量的声明是可以通过delete关键字删除的。删除之后就没有b的定义，无法console.log()</span><br><span class="line"></span><br><span class="line">delete a; //全局变量是不可以delete的，此处delete无效</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">//函数提升在前，变量提升在后</span><br><span class="line">var a = 3;</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(10);</span><br><span class="line">&#125;   </span><br><span class="line">console.log(a);</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">//提升的时候，变量声明位于函数之后</span><br><span class="line">等效于：</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(10)</span><br><span class="line">&#125;         //前</span><br><span class="line">var a;    //后</span><br><span class="line">a = 3;</span><br><span class="line">console.log(a);  //3</span><br><span class="line">a();  //not function</span><br><span class="line"></span><br><span class="line">//函数中出现和全局变量同名的变量  以及if中出现和全局变量同名的变量的处理方式</span><br><span class="line">var tmp = new Date();</span><br><span class="line">function f()&#123;</span><br><span class="line">    console.log(tmp);</span><br><span class="line">    if(false)&#123;</span><br><span class="line">        var tmp = &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">等效为：</span><br><span class="line">var tmp = new Date();</span><br><span class="line">function f()&#123;</span><br><span class="line">    var tmp;</span><br><span class="line">    console.log(tmp);</span><br><span class="line">    if(false)&#123;</span><br><span class="line">        tmp = &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为变量申明是在任意代码执行前处理的，在代码区中任意地方申明变量和在最开始（最上面）的地方申明是一样的。也就是说，看起来一个变量可以在申明之前被使用！这种行为就是所谓的“hoisting”，也就是变量提升，看起来就像变量的申明被自动移动到了函数或全局代码的最顶上。</span><br><span class="line"></span><br><span class="line">注意：仅仅是申明提升了，定义并不会被提升。</span><br><span class="line"></span><br><span class="line">//函数中出现和全局变量同名的变量  以及if中出现和全局变量同名的变量的处理方式</span><br><span class="line">var x = 1;</span><br><span class="line">console.log(x);</span><br><span class="line">if(true)&#123;</span><br><span class="line">    var x = 2;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);</span><br><span class="line"></span><br><span class="line">等效为</span><br><span class="line">var x = 1;</span><br><span class="line">console.log(x);</span><br><span class="line">if(true)&#123;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js的var变量只有全局作用域和函数作用域两种，且申明会被提升，因此实际上x只会在最顶上开始的地方申明一次，var x=2的申明会被忽略，仅用于赋值。也就是说上面的代码实际上跟下面是一致的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//匿名函数不存在预解析的问题</span><br><span class="line">f1();//-----报错</span><br><span class="line">var f1=function () &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a=10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的内存管理</title>
      <link href="/2017/09/29/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/09/29/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JS的内存管理"><a href="#JS的内存管理" class="headerlink" title="JS的内存管理"></a>JS的内存管理</h2><h3 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h3><p>​    JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。</p><a id="more"></a><p>　　垃圾收集机制原理：垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）， 周期性地执行这一操作：找出那些不再继续使用的变量，然后释放其占用的内存。</p><p>​    JS中大部分浏览器采用标记清除的垃圾回收机制，部分低版本的IE采用引用计数来实现垃圾的回收。</p><h3 id="JS垃圾回收机制-引用计数"><a href="#JS垃圾回收机制-引用计数" class="headerlink" title="JS垃圾回收机制-引用计数"></a>JS垃圾回收机制-引用计数</h3><h4 id="引用计数介绍"><a href="#引用计数介绍" class="headerlink" title="引用计数介绍"></a>引用计数介绍</h4><p>​    这种方式常常会引起内存泄漏，<strong>低版本的IE使用这种方式</strong>。</p><p>​    原理：当JavaScript代码生成一个新的内存驻留项时（比如一个对象或函数），系统就会为这个项留出一块内存空间。因为这个对象可能会被传递给很多函数，并且会被指定给很多变量，所以很多代码都会指向这个对象的内存空间。JavaScript会跟踪这些指针，当最后一个指针废弃不用时，这个对象占用的内存会被释放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ---------&gt; B ---------&gt; C</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如对象A有一个属性指向B，而B也有一个属性指向C。即使当前作用域中只有对象A有效，但由于指针的关系所有3个对象都必须保留在内存中。当离开A的当前作用域时（例如代码执行到声明A的函数的末尾处），垃圾收集器就可以释放A占用的内存。此时，由于没有什么指向B，因此B可以释放，最后，C也可以释放。</span></span><br></pre></td></tr></table></figure><h4 id="引用计数的问题-内存泄漏"><a href="#引用计数的问题-内存泄漏" class="headerlink" title="引用计数的问题-内存泄漏"></a>引用计数的问题-内存泄漏</h4><p>​    内存泄漏是指程序中己动态分配的堆<em>内存</em>由于某种原因程序未释放或无法释放，造成系统<em>内存</em>的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环引用导致内存泄漏 </span></span><br><span class="line">A ---------&gt; B ------------&gt; C</span><br><span class="line">             ^、_ _ _ _ _ _ _|</span><br><span class="line">                  </span><br><span class="line"><span class="comment">//这里，我们又为对象C添加了一个引用B的属性。在这种情况下，当A释放时，仍然有来自C的指针指向B。这种引用循环需要由JavaScript进行特殊的处理，但必须考虑到整个循环与作用域中的其他变量已经处于隔离状态。</span></span><br></pre></td></tr></table></figure><h4 id="什么时候会产生循环引用"><a href="#什么时候会产生循环引用" class="headerlink" title="什么时候会产生循环引用"></a>什么时候会产生循环引用</h4><h5 id="1-闭包的循环引用"><a href="#1-闭包的循环引用" class="headerlink" title="1.闭包的循环引用"></a>1.闭包的循环引用</h5><blockquote><p>​    闭包可能会导致在不经意间创建循环引用。因为函数是必须保存在内存中的对象，所以位于函数执行上下文中的所有变量也需要保存在内存中：</p></blockquote><h5 id="2-DOM与JavaScript的循环引用"><a href="#2-DOM与JavaScript的循环引用" class="headerlink" title="2.DOM与JavaScript的循环引用"></a>2.DOM与JavaScript的循环引用</h5><h3 id="JS垃圾回收机制-标记清除"><a href="#JS垃圾回收机制-标记清除" class="headerlink" title="JS垃圾回收机制-标记清除"></a>JS垃圾回收机制-标记清除</h3><h4 id="标记清除介绍"><a href="#标记清除介绍" class="headerlink" title="标记清除介绍"></a>标记清除介绍</h4><p>​    大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记清除算法由以下步骤组成：</span></span><br><span class="line"><span class="number">1.</span>垃圾回收器构建<span class="string">"roots"</span>列表。Roots通常是代码中保留引用的全局变量。在JavaScript中，<span class="string">"window"</span>对象可以作为 root 全局变量示例。</span><br><span class="line"><span class="number">2.</span>所有的<span class="string">"roots"</span>被检查并标记为active（即不是垃圾）。所有的children也被递归检查。从<span class="string">"root"</span>能够到达的一切都不被认为是垃圾。</span><br><span class="line"><span class="number">3.</span>所有为不被标记为active的内存可以被认为是垃圾了。收集器限制可以释放这些内存并将其返回到操作系统。</span><br></pre></td></tr></table></figure><p><img src="/2017/09/29/JavaScript的内存管理/" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-作用域</title>
      <link href="/2017/09/18/JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2017/09/18/JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域：变量可以起作用的范围</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><a id="more"></a><ul><li><p>全局变量</p><p>在任何地方都可以访问到的变量就是全局变量，对应全局作用域。在函数外声明。</p></li><li><p>局部变量</p><p>只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用var声明的变量是隐式全局变量，不推荐使用。</span><br><span class="line">变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁</span><br></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。<br><strong>在es5之前没有块级作用域的的概念,只有函数作用域</strong>，现阶段可以认为JavaScript没有块级作用域</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>因为 JavaScript 采用的是<strong>词法作用域，函数的作用域在函数定义的时候就决定了。</strong></p><p>而与词法作用域相对的是<strong>动态作用域，函数的作用域是在函数调用的时候才决定的。</strong></p><p><strong>在 js 中词法作用域规则:</strong></p><ul><li>函数允许访问函数外的数据.</li><li>整个代码结构中只有函数可以限定作用域.</li><li>作用域规则首先使用提升规则分析：声明会被提升，赋值不会提升</li><li>如果当前作用规则中有名字了, 就不考虑外面的名字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设JavaScript采用静态作用域，让我们分析下执行过程：</span><br><span class="line"></span><br><span class="line">执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 <span class="number">1</span>，所以结果会打印 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">假设JavaScript采用动态作用域，让我们分析下执行过程：</span><br><span class="line"></span><br><span class="line">执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>只有函数可以制造作用域结构。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</p><p>作用域链:变量的使用,从里向外,层层的搜索,搜索到了就可以直接使用了。层层搜索,搜索到0级作用域的时候,如果还是没有找到这个变量,结果就是报错</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的call,apply,bind</title>
      <link href="/2017/09/13/JavaScript%E4%B8%AD%E7%9A%84call-apply-bind/"/>
      <url>/2017/09/13/JavaScript%E4%B8%AD%E7%9A%84call-apply-bind/</url>
      
        <content type="html"><![CDATA[<h3 id="call、apply、bind：作用可以改变函数this的指向"><a href="#call、apply、bind：作用可以改变函数this的指向" class="headerlink" title="call、apply、bind：作用可以改变函数this的指向"></a>call、apply、bind：作用可以改变函数this的指向</h3><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和分别地提供的参数(参数的列表)。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：fun.call(thisArg,args...)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>(a+b);</span><br><span class="line">    <span class="built_in">console</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1.call(<span class="literal">null</span>,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参数：</span></span><br><span class="line"><span class="comment">1. thisArg</span></span><br><span class="line"><span class="comment">    在函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">    如果指定了 null 或者 undefined 则内部 this 指向 window</span></span><br><span class="line"><span class="comment">2.arg1, arg2, ...</span></span><br><span class="line"><span class="comment">    指定的参数列表</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数。</p><p>  注意：该方法的作用和 <code>call()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是若干个参数的列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>(a+b);</span><br><span class="line">    <span class="built_in">console</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1.call(<span class="literal">null</span>,[<span class="number">100</span>,<span class="number">200</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">1. thisArg</span></span><br><span class="line"><span class="comment">2. argsArray</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>apply()</code> 与 <code>call()</code> 非常相似，不同之处在于提供参数的方式。<br><code>apply()</code> 使用参数数组而不是一组参数列表。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用apply和call改变函数中this的指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"这个函数是window对象的一个方法:"</span>+(x+y)+<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.f1(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//obj是一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">     age:<span class="number">10</span>,</span><br><span class="line">     sex:<span class="string">"男"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.f1.apply(obj,[<span class="number">10</span>,<span class="number">20</span>]);</span><br><span class="line"><span class="built_in">window</span>.f1.call(obj,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(obj);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过apply和call改变原型方法中this的指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型添加方法</span></span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"您好啊:"</span>+<span class="keyword">this</span>.sex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">"男"</span>);</span><br><span class="line">per.sayHi();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"=============="</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"小明"</span>,<span class="string">"人妖"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1=per.sayHi.apply(stu,[<span class="number">10</span>,<span class="number">20</span>]);</span><br><span class="line"><span class="keyword">var</span> r2=per.sayHi.call(stu,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1);</span><br><span class="line"><span class="built_in">console</span>.log(r2);</span><br></pre></td></tr></table></figure><h4 id="apply和call方法的由来"><a href="#apply和call方法的由来" class="headerlink" title="apply和call方法的由来"></a>apply和call方法的由来</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>+<span class="string">":====&gt;调用了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f1是函数,f1也是对象</span></span><br><span class="line"><span class="built_in">console</span>.dir(f1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象调用方法,说明,该对象中有这个方法</span></span><br><span class="line">f1.apply();</span><br><span class="line">f1.call();</span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__==<span class="built_in">Function</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的函数都是Function的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);<span class="comment">//ƒ () &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Function</span>);</span><br><span class="line"><span class="comment">//apply和call方法实际上并不在函数这个实例对象中,而是在Function的prototype中</span></span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>​    bind函数是复制函数，在复制函数的时候改变了this的指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：fun.bind(thisArg,args...)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x+y);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> ff = f1.bind(per,<span class="number">10</span>,<span class="number">20</span>);  <span class="comment">//这边将f1函数复制了一份，同时改变了f1函数中this的指向</span></span><br><span class="line">ff();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.参数：</span></span><br><span class="line"><span class="comment">  1.1 thisArg</span></span><br><span class="line"><span class="comment">      当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</span></span><br><span class="line"><span class="comment">  1.2 arg1, arg2, ...</span></span><br><span class="line"><span class="comment">      当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.返回值：返回由指定的this值和初始化参数改造的原函数拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>示例1：对象方法中this的修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>+<span class="string">"====&gt;"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制了一份</span></span><br><span class="line"><span class="keyword">var</span> ff=per.play.bind(stu);</span><br><span class="line">ff();</span><br></pre></td></tr></table></figure><p>示例2：返回函数中this的修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.x; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 返回 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">// 返回 9, 在这种情况下，"this"指向全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，将"this"绑定到module对象</span></span><br><span class="line"><span class="comment">// 新手可能会被全局的x变量和module里的属性x所迷惑</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">// 返回 81</span></span><br></pre></td></tr></table></figure><p>示例3：定时器函数中this修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ShowRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ShowRandom.prototype.showRandom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//通过bind方法来修改定时器中this指向</span></span><br><span class="line">        <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> num = <span class="keyword">this</span>.produceNum();</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>),<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ShowRandom.prototype.produceNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">10</span>+<span class="number">1</span>);<span class="comment">//1~10的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> ShowRandom();</span><br><span class="line">    s.showRandom();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><p>call 和 apply 特性一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.都是用来调用函数，而且是立即调用</span><br><span class="line">2.但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向</span><br><span class="line">3.call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可</span><br><span class="line">4.apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递</span><br><span class="line">5.如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window</span><br></pre></td></tr></table></figure></li><li><p>bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数</span><br><span class="line">2.它和 call、apply 最大的区别是：bind 不会调用</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-函数</title>
      <link href="/2017/09/11/JavaScript-%E5%87%BD%E6%95%B0/"/>
      <url>/2017/09/11/JavaScript-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ul><li>函数声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>函数表达式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><p>函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。<br>函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 <code>tellStory</code> <code>sayHello</code>等</p></li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ul><li>调用函数的语法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名();</span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><p>函数体只有在调用的时候才会执行，调用需要()进行调用。<br>可以调用多次(重复使用)</p></li></ul><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"吃了没？"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">sayHi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1-100之间所有数的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span>  i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getSum();</span><br></pre></td></tr></table></figure><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul><li>为什么要有参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然上面代码可以重复调用，但是只能计算1-100之间的值</span></span><br><span class="line"><span class="comment">// 如果想要计算n-m之间所有数的和，应该怎么办呢？</span></span><br></pre></td></tr></table></figure><ul><li>语法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部</span></span><br><span class="line"><span class="comment">// 带参数的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的函数调用</span></span><br><span class="line">函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li><p>形参和实参</p><blockquote><ol><li>形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。</li><li>实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。</li></ol></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>, y = <span class="number">6</span>;</span><br><span class="line">fn(x,y); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y</span></span><br></pre></td></tr></table></figure><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><blockquote><p>当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值</p></blockquote><p>返回值语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个带返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过变量来接收这个返回值</span></span><br><span class="line"><span class="keyword">var</span> 变量 = 函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。</p><p>返回值详解：<br>    如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined<br>    如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值<br>    如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined<br>    函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。</p><h2 id="函数其它"><a href="#函数其它" class="headerlink" title="函数其它"></a>函数其它</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>匿名函数：没有名字的函数</p></blockquote><p>匿名函数如何使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将匿名函数赋值给一个变量，这样就可以通过变量进行调用</span><br><span class="line">匿名函数自调用</span><br></pre></td></tr></table></figure><p>关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。</p><h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><blockquote><p>匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">123</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="函数是一种数据类型"><a href="#函数是一种数据类型" class="headerlink" title="函数是一种数据类型"></a>函数是一种数据类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn);</span><br></pre></td></tr></table></figure><ul><li>函数作为参数</li></ul><p>​        因为函数也是一种类型，可以把函数作为两一个函数的参数，在两一个函数中调用</p><ul><li>函数做为返回值</li></ul><p>​        因为函数是一种类型，所以可以把函数可以作为返回值从函数内部返回，这种用法在后面很常见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">15</span>)();</span><br></pre></td></tr></table></figure><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.命名规范  </span><br><span class="line">2.变量规范   </span><br><span class="line">var name = &apos;zs&apos;;</span><br><span class="line">3.注释规范</span><br><span class="line">// 这里是注释</span><br><span class="line">4.空格规范</span><br><span class="line">5.换行规范</span><br><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">if (a &gt; b) &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链(有点复杂啊~)</title>
      <link href="/2017/08/29/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E7%82%B9%E5%A4%8D%E6%9D%82%E5%95%8A/"/>
      <url>/2017/08/29/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E7%82%B9%E5%A4%8D%E6%9D%82%E5%95%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="神奇的原型链"><a href="#神奇的原型链" class="headerlink" title="神奇的原型链"></a>神奇的原型链</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divObj=<span class="built_in">document</span>.getElementById(<span class="string">"dv"</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(divObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//divObj.__proto__----&gt;HTMLDivElement.prototype</span></span><br><span class="line"><span class="comment">//HTMLDivElement.prototype的__proto__---&gt;HTMLElement.prototype</span></span><br><span class="line"><span class="comment">//HTMLElement.prototype的__proto__----&gt;Element.prototype</span></span><br><span class="line"><span class="comment">//Element.prototype的__proto__----&gt;Node.prototype</span></span><br><span class="line"><span class="comment">//Node.prototype的__proto__----&gt;EventTarget.prototype</span></span><br><span class="line"><span class="comment">//EventTarget.prototype的__proto__----&gt;Object.prototype</span></span><br><span class="line"><span class="comment">//Object.prototype中的__proto__是null</span></span><br></pre></td></tr></table></figure><h3 id="原型链详解"><a href="#原型链详解" class="headerlink" title="原型链详解"></a>原型链详解</h3><p>​    构造函数的原型属性(prototype)中，除了拥有构造方法constructor之外，还有一个<strong> proto </strong>属性，该属性指向父亲的原型对象(prototype)。</p><p>​    对象的<strong> proto </strong>属性指向了函数的原型，就构成了原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.dir(per);<span class="comment">//实例对象的结构</span></span><br><span class="line"><span class="built_in">console</span>.dir(Person);<span class="comment">//构造函数的结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例对象中有__proto__原型</span></span><br><span class="line"><span class="comment">//构造函数中有prototype原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prototype是对象</span></span><br><span class="line"><span class="comment">//所以,prototype这个对象中也有__proto__,那么指向了哪里</span></span><br><span class="line"><span class="comment">//实例对象中的__proto__指向的是构造函数的prototype</span></span><br><span class="line"><span class="comment">//所以,prototype这个对象中__proto__指向的应该是某个构造函数的原型prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)   <span class="comment">//nul</span></span><br></pre></td></tr></table></figure><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 面向对象编程思想:根据需求,分析对象,找到对象有什么特征和行为,通过代码的方式来实现需求,要想实现这个需求,就要创建对象,要想创建对象,就应该显示有构造函数,然后通过构造函数来创建对象.,通过对象调用属性和方法来实现相应的功能及需求,即可</span></span><br><span class="line"><span class="comment">   * 首先JS不是一门面向对象的语言,JS是一门基于对象的语言,那么为什么学习js还要学习面向对象,因为面向对象的思想适合于人的想法,编程起来会更加的方便,及后期的维护....</span></span><br><span class="line"><span class="comment">   * 面向对象的编程语言中有类(class)的概念(也是一种特殊的数据类型),但是JS不是面向对象的语言,所以,JS中没有类(class),但是JS可以模拟面向对象的思想编程,JS中会通过构造函数来模拟类的概念(class)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 小明,小红，小丽，小白，小花 都是人</span></span><br><span class="line"><span class="comment">   * 共同的特征和行为</span></span><br><span class="line"><span class="comment">   * 特征---&gt;属性</span></span><br><span class="line"><span class="comment">   * 行为---方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 面向对象的特性:封装,继承,多态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 封装:就是包装</span></span><br><span class="line"><span class="comment">   * 一坨重复代码放在一个函数中--封装</span></span><br><span class="line"><span class="comment">   * 一系列的属性放在一个对象中--封装</span></span><br><span class="line"><span class="comment">   * 一些功能类似的函数(方法)放在一个对象中--封装</span></span><br><span class="line"><span class="comment">   * 好多相类似的对象放在一个js文件中---封装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 继承: 首先继承是一种关系,类(class)与类之间的关系,JS中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承</span></span><br><span class="line"><span class="comment">   * 继承也是为了数据共享,js中的继承也是为了实现数据共享</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 原型作用之一:数据共享,节省内存空间</span></span><br><span class="line"><span class="comment">   * 原型作用之二:为了实现继承</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 继承是一种关系:</span></span><br><span class="line"><span class="comment">   * 父类级别与类级别的关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 例子:</span></span><br><span class="line"><span class="comment">   * 人:  姓名, 性别, 年龄 ,吃饭, 睡觉</span></span><br><span class="line"><span class="comment">   * 学生类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 学习行为</span></span><br><span class="line"><span class="comment">   * 老师类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资,教学行为</span></span><br><span class="line"><span class="comment">   * 程序员: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资, 敲代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 动物类别:  体重， 颜色, 吃</span></span><br><span class="line"><span class="comment">   * 狗类别:   体重,颜色, 吃, 咬人</span></span><br><span class="line"><span class="comment">   * 猫类别: 体重,颜色, 吃, 咬人 逗主人开心,你好帅</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 多态:一个对象有不同的行为,或者是同一个行为针对不同的对象,产生不同的结果,要想有多态,就要先有继承*/</span></span><br></pre></td></tr></table></figure><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承例子:</span></span><br><span class="line"><span class="comment">//人,都有姓名,性别,年龄, 吃饭, 睡觉, 玩</span></span><br><span class="line"><span class="comment">//学生,都有姓名,性别,年龄, 成绩, 吃饭, 睡觉, 玩 ,学习的行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//js中通过原型来实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"人可以吃东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">score</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在改变学生原型对象之前先给学生的原型中添加一个sayHi方法(这个方法会出现什么情况?)</span></span><br><span class="line">Student.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi~~~"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变学生的原型的指向即可==========&gt;学生和人已经发生关系</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相同的代码太多,造成了代码的冗余(重复的代码)</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.age);</span><br><span class="line">stu.eat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"下面的是学生对象中自己有的"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.score);</span><br><span class="line">stu.sayHi();<span class="comment">//错误?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般步骤是：先修改函数原型，再向修改后的原型中添加信息</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承案例</span></span><br><span class="line"><span class="comment">//动物有名字,有体重,有吃东西的行为</span></span><br><span class="line"><span class="comment">//小狗有名字,有体重,有毛色, 有吃东西的行为,还有咬人的行为</span></span><br><span class="line"><span class="comment">//哈士奇名字,有体重,有毛色,性别, 有吃东西的行为,还有咬人的行为,逗主人开心的行为</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name,weight</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.weight=weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动物的原型的方法</span></span><br><span class="line">Animal.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"天天吃东西,就是吃"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//狗的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype=<span class="keyword">new</span> Animal(<span class="string">"哮天犬"</span>,<span class="string">"50kg"</span>);</span><br><span class="line">Dog.prototype.bitePerson=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哼~汪汪~咬死你"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈士奇</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErHa</span>(<span class="params">sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">ErHa.prototype=<span class="keyword">new</span> Dog(<span class="string">"黑白色"</span>);</span><br><span class="line">ErHa.prototype.playHost=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哈哈~要坏衣服,要坏桌子,拆家..嘎嘎...好玩,开心不,惊喜不,意外不"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> erHa=<span class="keyword">new</span> ErHa(<span class="string">"雄性"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(erHa.name,erHa.weight,erHa.color);</span><br><span class="line">erHa.eat();</span><br><span class="line">erHa.bitePerson();</span><br><span class="line">erHa.playHost();</span><br></pre></td></tr></table></figure><h3 id="构造函数的属性继承"><a href="#构造函数的属性继承" class="headerlink" title="构造函数的属性继承"></a>构造函数的属性继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面原型继承中为了数据共享,改变原型指向,做到了继承  ---通过改变原型指向实现的继承</span></span><br><span class="line"><span class="comment">//缺陷:因为改变原型指向的同时实现继承,直接初始化了属性，继承过来的属性的值都是一样的了,所以,这就是问题只能重新调用对象的属性进行重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方案:继承的时候,不用改变原型的指向,直接调用父级的构造函数的方式来为属性赋值就可以了  ------借用构造函数:把要继承的父级的构造函数拿过来,使用一下就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数继承属性成员</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Student(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.type, s1.name, s1.age) <span class="comment">// =&gt; human 张三 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//借用构造函数:构造函数名字.call(当前对象,属性,属性,属性....);</span></span><br><span class="line"><span class="comment">//解决了属性继承,并且值不重复的问题</span></span><br><span class="line"><span class="comment">//缺陷:父级类别中的方法不能继承</span></span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合继承:原型继承+借用构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"阿涅哈斯诶呦"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex,score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//借用构造函数:属性值重复的问题</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,age,sex);</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变原型指向----继承</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person();<span class="comment">//不传值</span></span><br><span class="line">Student.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的"小黑",20,"男","100分" 都是属于对象的信息，不是原型的信息</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"小黑"</span>,<span class="number">20</span>,<span class="string">"男"</span>,<span class="string">"100分"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name,stu.age,stu.sex,stu.score);</span><br><span class="line">stu.sayHi();</span><br><span class="line">stu.eat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu2=<span class="keyword">new</span> Student(<span class="string">"小黑黑"</span>,<span class="number">200</span>,<span class="string">"男人"</span>,<span class="string">"1010分"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu2.name,stu2.age,stu2.sex,stu2.score);</span><br><span class="line">stu2.sayHi();</span><br><span class="line">stu2.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性和方法都被继承了</span></span><br><span class="line"><span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><h3 id="构造函数的属性继承-拷贝继承"><a href="#构造函数的属性继承-拷贝继承" class="headerlink" title="构造函数的属性继承+拷贝继承"></a>构造函数的属性继承+拷贝继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象拷贝继承原型对象成员</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> Person.prototype) &#123;</span><br><span class="line">  Student.prototype[key] = Person.prototype[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Student(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">s1.sayName() <span class="comment">// =&gt; hello 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//效率较低，内存占用高（因为要拷贝父类的属性）</span></span><br><span class="line"><span class="comment">//无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</span></span><br><span class="line"><span class="comment">//不推荐使用</span></span><br></pre></td></tr></table></figure><h3 id="逆推继承看原型"><a href="#逆推继承看原型" class="headerlink" title="逆推继承看原型"></a>逆推继承看原型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F2</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F2.prototype = <span class="keyword">new</span> F1(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">F3.prototype = <span class="keyword">new</span> F2(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> F3(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f3.age);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="属性成员的搜索原则"><a href="#属性成员的搜索原则" class="headerlink" title="属性成员的搜索原则"></a>属性成员的搜索原则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当实例对象和原型中都有sex信息的时候，访问对象的属性获取的是谁的信息呢？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex=<span class="string">"女"</span>;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">"男"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per.sex);</span><br></pre></td></tr></table></figure><p>​    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 搜索首先从对象实例本身开始</span><br><span class="line">2. 如果在实例中找到了具有给定名字的属性，则返回该属性的值</span><br><span class="line">3. 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</span><br><span class="line">4. 如果在原型对象中找到了这个属性，则返回该属性的值</span><br><span class="line">5. 如果在原型对象中没有找到这个属性，则继续从父亲的原型中查找，有就返回</span><br></pre></td></tr></table></figure><p>​    也就是说，在我们调用   <code>per.sex</code> 的时候，会先后执行两次搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 首先，解析器会问：“实例 per 有 sex 属性吗？”答：“没有。</span><br><span class="line"><span class="number">2.</span> 然后，它继续搜索，再问：“ per 的原型有 sex 属性吗？”答：“没有。</span><br><span class="line"><span class="number">3.</span> 于是，它就从父亲的原型中查找有没有sex</span><br></pre></td></tr></table></figure><p>​    而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">1. 先在自己身上找，找到即返回</span><br><span class="line">2. 自己身上找不到，则沿着原型链向上查找，找到即返回</span><br><span class="line">3. 如果一直到原型链的末端还没有找到，则返回 undefined</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>元素的定位属性</title>
      <link href="/2017/08/15/%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/08/15/%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="元素的定位属性"><a href="#元素的定位属性" class="headerlink" title="元素的定位属性"></a>元素的定位属性</h2><p>元素的定位属性主要包括定位模式和边偏移两部分,只有定位了的盒子才可以使用这些属性</p><p>1、边偏移</p><a id="more"></a><table><thead><tr><th>边偏移属性</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>顶端偏移量，定义元素相对于其父元素上边线的距离</td></tr><tr><td>bottom</td><td>底部偏移量，定义元素相对于其父元素下边线的距离</td></tr><tr><td>left</td><td>左侧偏移量，定义元素相对于其父元素左边线的距离</td></tr><tr><td>right</td><td>右侧偏移量，定义元素相对于其父元素右边线的距离</td></tr></tbody></table><p>也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px;  left: 30px; 等等</p><p>2、定位模式(定位的分类)</p><p>在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：</p><p>选择器{position:属性值;}</p><p>position属性的常用值</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>static</td><td>自动定位（默认定位方式）</td></tr><tr><td>relative</td><td>相对定位，相对于其原文档流的位置进行定位</td></tr><tr><td>absolute</td><td>绝对定位，相对于其上一个已经定位的父元素进行定位</td></tr><tr><td>fixed</td><td>固定定位，相对于浏览器窗口进行定位</td></tr></tbody></table><h2 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位(static)"></a>静态定位(static)</h2><p>静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。</p><p>上面的话翻译成白话：  就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。</p><p>在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。</p><p>PS： 静态定位其实没啥可说的。</p><h2 id="相对定位relative"><a href="#相对定位relative" class="headerlink" title="相对定位relative"></a>相对定位relative</h2><p>相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。</p><p>对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留</p><p>注意：   </p><ol><li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。</li><li>其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）</li></ol><p>就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）</p><p>如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。</p><h2 id="绝对定位absolute"><a href="#绝对定位absolute" class="headerlink" title="绝对定位absolute"></a>绝对定位absolute</h2><p>[注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。</p><p>当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。</p><p>注意：    绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。</p><h3 id="父级没有定位"><a href="#父级没有定位" class="headerlink" title="父级没有定位"></a>父级没有定位</h3><p>若所有父元素都没有定位，以浏览器为准对齐(document文档)。</p><h3 id="父级有定位"><a href="#父级有定位" class="headerlink" title="父级有定位"></a>父级有定位</h3><p>绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 </p><h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h3><p>这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。这句话的意思是 子级是绝对定位的话， 父级要用相对定位。</p><p>首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。</p><p>就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。</p><p>所以，我们可以得出如下结论：</p><p>因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。</p><p>父盒子布局时，需要占有位置，因此父亲只能是 相对定位. </p><p>这就是子绝父相的由来。</p><h2 id="绝对定位的盒子水平-垂直居中"><a href="#绝对定位的盒子水平-垂直居中" class="headerlink" title="绝对定位的盒子水平/垂直居中"></a>绝对定位的盒子水平/垂直居中</h2><p>普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了</p><p>定位的盒子也可以水平或者垂直居中，有一个算法。</p><ol><li>首先left 50%   父盒子的一半大小</li><li>然后走自己外边距负的一半值就可以了 margin-left。</li></ol><h2 id="固定定位fixed"><a href="#固定定位fixed" class="headerlink" title="固定定位fixed"></a>固定定位fixed</h2><p>固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。</p><p>当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。</p><p>固定定位有两点：</p><ol><li>固定定位的元素跟父亲没有任何关系，只认浏览器。</li><li>固定定位完全脱标，不占有位置，不随着滚动条滚动。。</li></ol><p>ie6等低版本浏览器不支持固定定位。</p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。</p><p>在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。</p><p>比如：  z-index: 2;</p><p>注意：</p><ol><li><p>z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。</p></li><li><p>如果取值相同，则根据书写顺序，后来居上。</p></li><li><p>后面数字一定不能加单位。</p></li><li><p>只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。</p><p>​</p><p>​</p><p><strong>四种定位总结</strong></p></li></ol><table><thead><tr><th>定位模式</th><th>是否脱标占有位置</th><th>是否可以使用边偏移</th><th>移动位置基准</th></tr></thead><tbody><tr><td>静态static</td><td>不脱标，正常模式</td><td>不可以</td><td>正常模式</td></tr><tr><td>相对定位relative</td><td>不脱标，占有位置</td><td>可以</td><td>相对自身位置移动（自恋型）</td></tr><tr><td>绝对定位absolute</td><td>完全脱标，不占有位置</td><td>可以</td><td>相对于定位父级移动位置（拼爹型）</td></tr><tr><td>固定定位fixed</td><td>完全脱标，不占有位置</td><td>可以</td><td>相对于浏览器移动位置（认死理型）</td></tr></tbody></table><h1 id="定位模式转换"><a href="#定位模式转换" class="headerlink" title="定位模式转换"></a>定位模式转换</h1><p>跟浮动一样， 元素添加了绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为行内块模式，</p><p>因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。</p><h1 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h1><p>在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。</p><p>他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！</p><h2 id="display-显示"><a href="#display-显示" class="headerlink" title="display 显示"></a>display 显示</h2><p>display 设置或检索对象是否及如何显示。</p><p>display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。</p><p>特点： 隐藏之后，不再保留位置。</p><h2 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h2><p>设置或检索是否显示对象。</p><p>visible : 　对象可视</p><p>hidden : 　对象隐藏</p><p>特点： 隐藏之后，继续保留原有位置</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo和git建立博客</title>
      <link href="/2017/07/01/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgit%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/07/01/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgit%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h2><h4 id="1-搭建Node-js环境"><a href="#1-搭建Node-js环境" class="headerlink" title="1.搭建Node.js环境"></a><strong>1.搭建Node.js环境</strong></h4><p>搭建博客网站首先需要安装Node.js环境。</p><p>下载地址：<a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a> </p><p>测试安装：命令行使用node -v 、npm -v，查看显示版本号即成功。</p><a id="more"></a><h4 id="2-安装Hexo博客框架工具"><a href="#2-安装Hexo博客框架工具" class="headerlink" title="2. 安装Hexo博客框架工具"></a>2. <strong>安装Hexo博客框架工具</strong></h4><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在</p><p>控制台下（cmd）使用如下命令：</p><p>npm install hexo-cli -g</p><h4 id="3-安装Git版本工具"><a href="#3-安装Git版本工具" class="headerlink" title="3.安装Git版本工具"></a><strong>3.安装Git版本工具</strong></h4><h4 id="Git是目前世界上最流行的分布式版本控制系统"><a href="#Git是目前世界上最流行的分布式版本控制系统" class="headerlink" title="Git是目前世界上最流行的分布式版本控制系统"></a>Git是目前世界上最流行的分布式版本控制系统</h4><h4 id="使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。"><a href="#使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。" class="headerlink" title="使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。"></a>使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。</h4><h4 id="下载地址：https-git-scm-com-downloads"><a href="#下载地址：https-git-scm-com-downloads" class="headerlink" title="下载地址：https://git-scm.com/downloads"></a>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></h4><p><em>测试安装:右击鼠标，如果有git bash等两个选项 即安装成功。</em></p><h4 id="4-注册Github账号"><a href="#4-注册Github账号" class="headerlink" title="4.注册Github账号"></a><strong>4.注册Github账号</strong></h4><p> gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式</p><p>进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。 </p><p>注册地址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a>  </p><h2 id="二、开始搭建博客"><a href="#二、开始搭建博客" class="headerlink" title="二、开始搭建博客"></a>二、<strong>开始搭建博客</strong></h2><h4 id="1-开启GitHub服务"><a href="#1-开启GitHub服务" class="headerlink" title="1. 开启GitHub服务"></a>1. <strong>开启GitHub服务</strong></h4><p> 通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/1.png" alt="img"></p><p>新仓库的名字，最好是是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<a href="https://UserName.github.io的形式。" target="_blank" rel="noopener">https://UserName.github.io的形式。</a> </p><p>注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很长</p><p>点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/2.png" alt="img"></p><p>这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/3.png" alt="img"></p><p>再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/4.png" alt="img"></p><p>现在，可以使用<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">https://UserName.github.io</a>，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然点丑)：</p><p><img src="/2017/07/01/使用hexo和git建立博客/5.png" alt="img"></p><h4 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2.创建本地博客站点"></a><strong>2.创建本地博客站点</strong></h4><p>上述的步骤相当于我们使用Github，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很丑。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台(cmd)命令在本地一个合适的位置创建博客站点文件夹如下：</p><p><strong>hexo init myHexoBlog</strong> <strong>//myHexoBlog是项目名</strong></p><p><img src="/2017/07/01/使用hexo和git建立博客/6.png" alt="img"></p><p>测试本地博客站点，在本地博客根目录(git bash)下使用控制台命令：</p><p>hexo g <em>//g是generetor的缩写，生成博客</em> </p><p>hexo s <em>//s是server的缩写，启动服务</em></p><p>此时打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，我们将会看到Hexo自带默认主题显示的博客样式如下:</p><p><img src="/2017/07/01/使用hexo和git建立博客/7.png" alt="img"></p><h4 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3.同步Github,允许公共访问"></a><strong>3.同步Github,允许公共访问</strong></h4><p> 初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are.</p><p><img src="/2017/07/01/使用hexo和git建立博客/8.png" alt="img"></p><p>你需要运行命令来配置你的用户名和邮箱：</p><p>$ git config –global user.name “xx”</p><p>$ git config –global user.email “<a href="mailto:xxx@xx.com" target="_blank" rel="noopener">xxx@xx.com</a>“</p><p><strong>注意：（引号内请输入你自己设置的名字，和你自己的邮箱）</strong>此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱</p><h3 id="git配置SSH-Key"><a href="#git配置SSH-Key" class="headerlink" title="git配置SSH Key"></a><strong>git配置SSH Key</strong></h3><p>1、 打开git bash.exe</p><p>2、检查是否已经有SSH Key  $ cd ~/.ssh</p><p>3、生成SSH Key  $  ssh-keygen -t rsa -C “youremail”</p><p>第一次生成的话，直接一路回车，不需要输入密码。不是第一次生成的话，会提示 overwrite (y/n)? 问你是否覆盖旧的 SSH Key ，直接填 y ，然后一直回车就行了，最后得到了两个文件：id_rsa和id_rsa.pub。<br><img src="/2017/07/01/使用hexo和git建立博客/9.png" alt="img"></p><p>4、记事本打开/C/Users/Administrator/.ssh/下id_rsa.pub文件，复制该段信息；登录github账户，点击头像进入Settings -&gt; SSH and GPG keys -&gt; New SSH key，将复制的信息粘贴到该处。<br><img src="/2017/07/01/使用hexo和git建立博客/10.png" alt="img"></p><p>5、测试是否成功$ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><p>提示“Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.”说明添加成功。</p><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。首先找到我们的博客仓库，并拷贝仓库地址：<img src="/2017/07/01/使用hexo和git建立博客/11.png" alt="img"></p><p>然后修改本地博客目录的配置：<br>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/12.png" alt="img"></p><p>之后执行控制台命令(cmd)：</p><p>npm install hexo-deployer-git <em>//安装部署插件</em></p><p> hexo d <em>//部署到github</em></p><p>再次访问链接：<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">https://userName.github.io</a>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p><h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、<strong>发布博客</strong></h2><p>  可以发布自己的第一篇博客了。来尝试一下以下的步骤：<br>在本地博客文件夹根目录(git bash)输入：</p><p>hexo new “我个人博客的第一篇博客” </p><p>hexo g <em>//生成网页</em> </p><p>hexo d <em>//部署到远端(github)</em></p><p><img src="/2017/07/01/使用hexo和git建立博客/13.png" alt="img"></p><p>现在打开我们的博客网站：<a href="http://username.github.io/" target="_blank" rel="noopener">http://UserName.github.io</a>,会看到网页</p><p>（显示可能有延迟 所以可以采用以下方法(git bash)：</p><p> hexo clean <em>//清理缓存</em> </p><p>hexo g <em>//重新生成博客代码</em> </p><p>hexo d <em>//部署到本地</em></p><p><em>稍等即可</em></p><p><em>顺便一提</em> <em>hexo s</em> <em>启动本地服务器，用于预览</em></p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a><strong>四、更换主题</strong></h2><p> 为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主</p><p>题下自己编写美化博客界面）。这里以使用github上的next主题为例：</p><h4 id="1-创建next文件夹"><a href="#1-创建next文件夹" class="headerlink" title="1.创建next文件夹"></a><strong>1.创建next文件夹</strong></h4><p>切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题(git bash)</p><p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><p><em>//下载主题</em></p><p>下载成之后我们会看到next的主题已经存在thems里了如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/14.png" alt="img"></p><h4 id="3-修改博客配置文件，更换主题配置"><a href="#3-修改博客配置文件，更换主题配置" class="headerlink" title="3.修改博客配置文件，更换主题配置"></a><strong>3.修改博客配置文件，更换主题配置</strong></h4><p>修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next</p><p><img src="/2017/07/01/使用hexo和git建立博客/15.png" alt="img"></p><p>然后在控制台（git bash）下输入如下命令：</p><p>hexo clean <em>//清理缓存</em></p><p> hexo g <em>//重新生成博客代码</em> </p><p>hexo d <em>//部署到本地</em></p><p>再次打开我们的博客网站<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">https://UserName.github.io</a>，将会看到更换主题后</p><p>更多主题美化：</p><p><a href="https://blog.csdn.net/qq_32454537/article/details/79482896" target="_blank" rel="noopener">https://blog.csdn.net/qq_32454537/article/details/79482896</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 小白 git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
