<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue的基本概念</title>
      <link href="/2018/12/13/Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/12/13/Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul><li><p>Vue.js是是一套用于构建用户界面的<strong>渐进式框架</strong>，是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p><a id="more"></a></li><li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</p></li><li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p></li></ul><h3 id="Vue的核心思想"><a href="#Vue的核心思想" class="headerlink" title="Vue的核心思想"></a>Vue的核心思想</h3><blockquote><ul><li>数据驱动，没有dom操作，页面显示由数据驱动</li><li>组件化，一个页面可以划分成很多组件</li><li>状态管理 ，vuex，可用于在多个页面之间进行数据共享</li></ul></blockquote><p>​    Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p><h3 id="1-1-5-MVC和MVVM"><a href="#1-1-5-MVC和MVVM" class="headerlink" title="1.1.5.MVC和MVVM"></a>1.1.5.MVC和MVVM</h3><h4 id="a-MVC"><a href="#a-MVC" class="headerlink" title="a) MVC"></a>a) MVC</h4><p>​    M - Model ：数据保存</p><p>​    V - View : 用户界面</p><p>​    C - Controller ： 业务逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户操作--&gt; View (负责接受用户的输入操作)--&gt;Controller（业务逻辑处理）--&gt;Model（数据持久化）--&gt;View（将结果通过View反馈给用户）</span><br></pre></td></tr></table></figure><p>​    MVC有两个很明显的问题：</p><p>​    1.m层和v层直接打交道，导致这两层耦合度高</p><p>​    2.因为所有逻辑都写在c层，导致c层特别臃肿</p><h4 id="b-MVVM"><a href="#b-MVVM" class="headerlink" title="b) MVVM"></a>b) MVVM</h4><p>​    前端应用的复杂程度已不同往日，暴露出了三个痛点问题：</p><p>　　1.开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。</p><p>　　2.大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p><p>　　3.当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</p><p>　　早期 jQuery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。</p><p>​    MVVM 的出现，完美解决了以上三个问题，MVVM 包含的三部分：</p><p>　　1.Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；</p><p>　　2.View 代表UI 组件，它负责将数据模型转化成UI 展现出来</p><p>　　3.ViewModel 是一个同步View 和 Model的对象。View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图：</p><p>​    MVVM 模式采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。angular 和vue都采用这种模式。</p><h4 id="c-前后端的MVC"><a href="#c-前后端的MVC" class="headerlink" title="c) 前后端的MVC"></a>c) 前后端的MVC</h4><p>​    一般情况下，后端的框架中多数采用MVC模式，比如structs2、springMVC、ASP.MVC、Express等</p><p>​    前端MVC大部分都是MVVM，包括angularJS、vue等。前后端分离的情况下，后端的MVC框架主要负责JSON数据的返回。</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li><p>.stop       阻止冒泡</p></li><li><p>.prevent    阻止默认事件</p></li><li><p>.capture    添加事件侦听器时使用事件捕获模式</p></li><li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once       事件只触发一次</p><h3 id="v-model和双向绑定"><a href="#v-model和双向绑定" class="headerlink" title="v-model和双向绑定"></a>v-model和双向绑定</h3><p>​    只有v-model指令实现了双向绑定， v-model 只能运用在表单元素中。如： input(radio, text, address, email….)   select    checkbox   textarea</p><h3 id="双向绑定的原理"><a href="#双向绑定的原理" class="headerlink" title="双向绑定的原理"></a>双向绑定的原理</h3><h4 id="页面–-gt-数据"><a href="#页面–-gt-数据" class="headerlink" title="页面–&gt;数据"></a>页面–&gt;数据</h4><p>​    view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现</p><h4 id="数据–-gt-页面"><a href="#数据–-gt-页面" class="headerlink" title="数据–&gt;页面"></a>数据–&gt;页面</h4><p>​    是通过数据劫持 + 发布者-订阅者模式的方式来实现的</p><h5 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h5><p>​    vue是通过Object.defineProperty()来实现数据劫持的</p><h5 id="数据绑定的实现流程"><a href="#数据绑定的实现流程" class="headerlink" title="数据绑定的实现流程"></a>数据绑定的实现流程</h5><p>​    首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。</p><p>​    因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。</p><p>​    接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p><p>​    因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p><blockquote><p>1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。</p><p>2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者</p></blockquote></li></ul><h4 id="循环中key的使用"><a href="#循环中key的使用" class="headerlink" title="循环中key的使用"></a>循环中key的使用</h4><p>​    当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>​    为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p><h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><p>​    一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB的介绍</title>
      <link href="/2018/08/25/MongoDB%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/08/25/MongoDB%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB基本原理"><a href="#MongoDB基本原理" class="headerlink" title="MongoDB基本原理"></a><strong>MongoDB基本原理</strong></h2><p>什么是数据库？关能存储数据的东西是数据库么？不是。txt也能存储东西，但是txt不是数据库。</p><p>因为<strong>数据库 = 存储东西 + 数据库操作API</strong>。</p><a id="more"></a><p>我们不仅仅能够存储100个学生，而且要能快速查找其中大于15岁且语文成绩大于80分的人。txt做不到这个事情，所以txt文本文件只是持久数据的一种方式，但是不是数据库。</p><p>MongoDB存储JSON，并且不是简单的存储JSON，而是能够非常方便的使用简单的API去检索数据。 </p><p>数据从头到尾是不变形的，用户提交的表单是JSON，存储到数据库中也是JSON。反过来说，从数据库中提取的是JSON，前端Ajax读取的也是JSON。数据从头到尾不变形，非常美！</p><p>MongoDB是NoSQl，非结构型数据库。比SQL好在哪儿？不限制字段，每个条目（MongoDB中称为文档，一个文档就是一个标准JSON）都可以有自己的字段，比如下面的四个文档是合法的：</p><p>{“uname”:”小明”,”age”:12,”sex”:”男”}</p><p>{“uname”:”小红”,”age”:13,”sex”:”女”}</p><p>{“uname”:”小刚”,”age”:12,”sex”:”男”,”provice”:”广东”}</p><p>{“title”:”一人我饮酒醉”,”singer”:”天佑”}</p><p>第3个文档增加了一个字段，第4个文档干脆就存储的和前三个没有关系。MongoDB是合法的，不限制文档的字段。</p><p>数据库由集合（collection）组成，集合由文档（document）构成：</p><p><img src="file:///C:\Users\zz\AppData\Local\Temp\ksohtml\wpsEA65.tmp.jpg" alt="img"> </p><p>虽然MongoDB允许我们一个集合中的所有文档有不同的字段，但是最好一个集合中存储相关的数据。比如你存储学生就存储学生，不要存储歌曲、小狗。</p><h2 id="MongoDB的开机"><a href="#MongoDB的开机" class="headerlink" title="MongoDB的开机"></a>MongoDB的开机</h2><p>在CMD中要先使用mongod开机，然后使用mongo控制数据库。 </p><p>首先应该建立一个文件夹，存储数据库数据：</p><p>$ cd c:\</p><p>$ mkdir mydatabase</p><p>使用mongod开机：</p><p>$ mongod –dbpath c:\mydatabase</p><p>此时需要再打开一个CMD窗口，用mongo命令进入REPL环境。 </p><p>Read读命令，Eval执行命令，Print打印结果，Loop再来一次。</p><p>在笔记上，用$开头的都是CMD命令，</p><p>$</p><p>>会暗示你这是REPL命令：</p><p>></p><h2 id="MongoDB常用REPL命令"><a href="#MongoDB常用REPL命令" class="headerlink" title="MongoDB常用REPL命令"></a><strong>MongoDB常用REPL命令</strong></h2><p>一定注意，下面列出的命令都需要事先进入mongo里面的REPL环境敲击。</p><p>查看数据库列表：</p><p>> show dbs </p><p>使用某一个数据库，如果不存在则创建（当你插入了一个数据之后创建）</p><p>> use xueshe </p><p>插入数据，这条命令会自动创建集合banji1120。也就是说创建数据库用use，创建集合没有命令。插入文档了，就创建集合了。</p><p>> db.banji1120.insert({“uname”:”小明”,”age”:12,”sex”:”男”})</p><p>显示所有数据</p><p>> db.banji1120.find()</p><p>显示当前数据库中的所有集合</p><p>> show collections </p><p>删除集合：</p><p>>  db.bangi1120.drop()</p><p>删除数据库：</p><p>>  db.dropDatabase()</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a><strong>导入数据</strong></h2><p>下面的命令不需要进入REPL环境！！</p><p>数据库仍然要维持开机状态。再次强调，千万不要进入REPL中使用下面的命令！</p><p>在桌面创建这个文件，JSON和JSON之间没有逗号：</p><p>{“uname”:”李灵黛”,”age”:12,”sex”:”男”,”provice”:”上海”}</p><p>{“uname”:”柳辰飞”,”age”:13,”sex”:”女”,”provice”:”北京”}</p><p>{“uname”:”江城子”,”age”:17,”sex”:”男”,”provice”:”广东”}</p><p>{“uname”:”萧合凰”,”age”:37,”sex”:”女”,”provice”:”河北”}</p><p>{“uname”:”西粼宿”,”age”:16,”sex”:”男”,”provice”:”广东”}</p><p>{“uname”:”千湄”,”age”:13,”sex”:”女”,”provice”:”广东”}</p><p>{“uname”:”林墨瞳”,”age”:13,”sex”:”女”,”provice”:”吉林”}</p><p>{“uname”:”柳婵诗”,”age”:14,”sex”:”女”,”provice”:”河北”}</p><p>{“uname”:”李念儿”,”age”:19,”sex”:”女”,”provice”:”广东”}</p><p>$ mongoimport -d xuesheng -c banji1120 C:\Users\Danny\Desktop\1.txt</p><p>-d参数表示需要往哪个数据库中导入数据</p><p>-c 参数表示需要往哪个集合(表)中导入数据</p><p>最后罗列需要导入的txt文档。</p><p>提示你成功的导入了9条文档 </p><p>导出的方法自己百度。mongoexport基本参数自己查文档、博客学习。</p><h1 id="NodeJS结合MongoDB"><a href="#NodeJS结合MongoDB" class="headerlink" title="NodeJS结合MongoDB"></a><strong>NodeJS结合MongoDB</strong></h1><h2 id="用NodeJS操作MongoD"><a href="#用NodeJS操作MongoD" class="headerlink" title="用NodeJS操作MongoD"></a>用NodeJS操作MongoD</h2><p>数据库一定给各种语言提供API，比如PHP可以操作MySQL。</p><p>NodeJS可以方便操作MongoDB。</p><p>依赖的东西叫做mongodb</p><p>$ cnpm install –save mongodb</p><p>链接数据库并且试着检索数据：</p><p>/*</p><ul><li><p>链接数据库的API，不要背诵，直接复制：</p></li><li><p><a href="http://mongodb.github.io/node-mongodb-native/2.2/" target="_blank" rel="noopener">http://mongodb.github.io/node-mongodb-native/2.2/</a></p></li><li><p><a href="http://mongodb.github.io/node-mongodb-native/2.2/quick-start/quick-start/" target="_blank" rel="noopener">http://mongodb.github.io/node-mongodb-native/2.2/quick-start/quick-start/</a></p></li></ul><p>*/</p><p>var MongoClient = require(‘mongodb’).MongoClient;</p><p>// 链接数据库，最后的反斜杠表示数据库的名字</p><p>var url = ‘mongodb://localhost:27017/xuesheng’;</p><p>// 标准动作，连接数据库之后然后对数据库进行CRUD操作</p><p>MongoClient.connect(url, function(err, db) {</p><p>​    if(err){</p><p>​        console.log(“连接数据库失败，因为你忘记了mongod开机”);</p><p>​        return;</p><p>​    }</p><p>​    console.log(“链接数据库成功”);</p><p>​    //检索所有年龄大于15岁并且是广东的男的</p><p>​    db.collection(“banji1120”).find(</p><p>​        {“age” : {$gt : 15} , “provice” : “广东” , “sex” : “男”}</p><p>​    ).toArray(function(err,arr){</p><p>​        console.log(arr);</p><p>​        //关闭数据库</p><pre><code>db.close();</code></pre><p>​    });</p><p>});</p><p>其他增删改查操作，看昨天的案例。或者手册：</p><p><a href="http://mongodb.github.io/node-mongodb-native/2.2/tutorials/crud/" target="_blank" rel="noopener">http://mongodb.github.io/node-mongodb-native/2.2/tutorials/crud/</a></p><h2 id="结合Express做一个带数据库的程序"><a href="#结合Express做一个带数据库的程序" class="headerlink" title="结合Express做一个带数据库的程序"></a>结合Express做一个带数据库的程序</h2><p>最俗套学生管理系统，能够增、删学生。</p><p>MongoDB不多做案例，因为MongoDB是反MVC开发模式的，现在都需要结合Mongoose来开发。</p><p>写了一个项目project_StudentManagement自己看代码。只粘贴模型：</p><p>models/db.js：</p><p>var MongoClient = require(‘mongodb’).MongoClient;</p><p>// 链接数据库，最后的反斜杠表示数据库的名字</p><p>var url = ‘mongodb://localhost:27017/xuesheng’;</p><p>//得到所有数据</p><p>function getAllStudent(callback){</p><p>​    // 标准动作，连接数据库之后然后对数据库进行CRUD操作</p><p>​    MongoClient.connect(url, function(err, db) {</p><p>​        if(err){</p><p>​            console.log(“连接数据库失败，因为你忘记了mongod开机”);</p><p>​            return;</p><p>​        }</p><p>​        console.log(“链接数据库成功”);</p><p>​        //检索所有人</p><p>​        db.collection(“banji1120”).find({}).toArray(function(err,arr){</p><p>​            callback(arr);</p><p>​            //关闭数据库</p><p>​             db.close();</p><p>​        });</p><p>​    });</p><p>}</p><p>//暴露</p><p>exports.getAllStudent = getAllStudent;</p><p>结构：</p><p>我们用jQuery去发出Ajax请求，然后用underscore填充模板：</p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><br><br><head><meta name="generator" content="Hexo 3.8.0"><br><br>​    <meta charset="UTF-8"><br><br>​    <title>学生管理系统</title><br><br>​    <style type="text/css"><br><br>​    </style><br><br></head><br><br><body><br><br>​    <section><br><br>​        <h1>学生管理系统</h1><br><br>​        <table id="biaoge2"><br><br>​            <tr><br><br>​                <th>姓名</th><br><br>​                <th>年龄</th><br><br>​                <th>性别</th><br><br>​                <th>籍贯</th><br><br>​            </tr><br><br>​        </table><br><br>​    </section><br><br><br><br>​    <script type="text/template"><br><br>​        <tr><br><br>​            <td>&lt;%= name %&gt;</td><br><br>​            <td>&lt;%= age %&gt;</td><br><br>​            <td>&lt;%= sex %&gt;</td><br><br>​            <td>&lt;%= provice %&gt;</td><br><br>​        </tr><br><br>​    </script><br><br><br><br>​    <script type="text/javascript" src="/jquery.min.js"></script><br><br>​    <script type="text/javascript" src="/underscore.min.js"></script><br><br><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":100,"height":100},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><br><br></html><p>underscore和ejs的标记冲突，所以ejs傻不拉几的认为你没有传入足够的字典数据。</p><p>改变underscore的源代码，搜索&lt;%这个东西，就能定位这里：</p><h1 id="Mongoose初步"><a href="#Mongoose初步" class="headerlink" title="Mongoose初步"></a><strong>Mongoose初步</strong></h1><h2 id="Mongoose简介"><a href="#Mongoose简介" class="headerlink" title="Mongoose简介"></a><strong>Mongoose简介</strong></h2><p>看看mongodb编程有什么不方便的地方：</p><p>1） 如果集合非常多的话，此时你的模型层势必要有这样的写法：</p><p>//得到所有数据</p><p>function <strong>getAllStudent</strong>(callback){</p><p>​    // 标准动作，连接数据库之后然后对数据库进行CRUD操作</p><p>​    MongoClient.connect(url, function(err, db) {</p><p>​        //检索所有人</p><p>​        db.collection(“student”).find({}).toArray(function(err,arr){</p><p>​            callback(arr);</p><p>​            //关闭数据库</p><p>​             db.close();</p><p>​        });</p><p>​    });</p><p>}</p><p>function <strong>getAllDog</strong>(callback){</p><p>​    // 标准动作，连接数据库之后然后对数据库进行CRUD操作</p><p>​    MongoClient.connect(url, function(err, db) {</p><p>​        //检索所有人</p><p>​        db.collection(“dog”).find({}).toArray(function(err,arr){</p><p>​            callback(arr);</p><p>​            //关闭数据库</p><p>​             db.close();</p><p>​        });</p><p>​    });</p><p>}</p><p>控制每个不同的集合，有大量类似的代码，对每个集合都要有增删改查的操作。代码比较臃肿。</p><p>2）数据库代码永远使用的是一个没有结构的、面向过程的编程模式。我永远要思考数据的事情，编程的时候要考虑的事情太多。</p><p>Java中也出现了这样的问题，Java的Hibernate框架解决了这个事情。</p><p>Hibernate是一个<strong>ORM框架，Object Relationship Map，对象关系映射。一句话，就是让程序员可以用面向对象的思维操作数据库，换句话说，根本不需要考虑数据的持久化，对象改变了，数据自动改变。</strong></p><p>Mongoose是配合MongoDB使用的ORM库。我们操作数据库太爽了，不需要想到有数据库这个事情，只需要操作对象，数据会被Mongoose自动持久。</p><p>Mongoose是猫鼬的意思： </p><p>官网：<a href="http://mongoosejs.com/" target="_blank" rel="noopener">http://mongoosejs.com/</a></p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a><strong>HelloWorld</strong></h2><p>安装依赖：</p><p>$ cnpm install mongoose –save</p><p>最基本的使用：</p><p>//引入mongoose，mongoose的依赖中自动有mongodb的，所以不需要再次引入mongodb</p><p>var mongoose = require(‘mongoose’);</p><p>//链接数据库，端口号不需要写，最后的反斜杠是数据库名字</p><p>mongoose.connect(‘mongodb://localhost/ceshi’);</p><p>//用mongoose.model()函数创建一个模型，是一个类。此时你传入的第一个参数将自动大写变为小写，末尾加s，变为集合名字。第二个参数是<em>schema</em>，就是字段列表，用kv对表示字段名字和类型。</p><p>var Student = mongoose.model(‘Student’, { </p><p>​    sname : String,</p><p>​    sex : String,</p><p>​    age : Number</p><p>});</p><p>//实例化对象</p><p>var xiaoming = new Student({</p><p>​    sname : “小明”,</p><p>​    sex : “男”,</p><p>​    age : 12</p><p>});</p><p><strong>//保存对象</strong></p><p>xiaoming.save(); </p><p>程序一旦运行：</p><p>系统就会帮我们创建ceshi数据库，创建students集合名字，保存小明这一条数据。 </p><p>此时你会发现，我们没有一条语句是明显的在操作数据库，底层操作由Mongoose帮我们完成。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>express的相关概念</title>
      <link href="/2018/07/13/express%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/07/13/express%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Express"><a href="#1-Express" class="headerlink" title="1.Express"></a>1.Express</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>​    Express是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。使用 Express 可以快速地搭建一个完整功能的网站，它有一套健壮的特性，可用于开发单页、多页和混合Web应用。</p><a id="more"></a><h3 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h3><h4 id="1-2-1-安装express"><a href="#1-2-1-安装express" class="headerlink" title="1.2.1 安装express"></a>1.2.1 安装express</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myapp</span><br><span class="line">$ cd myapp</span><br><span class="line">$ npm init</span><br><span class="line">entry point: (index.js)</span><br><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure><h4 id="1-2-2-基本使用"><a href="#1-2-2-基本使用" class="headerlink" title="1.2.2 基本使用"></a>1.2.2 基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 安装</span></span><br><span class="line"><span class="comment">// 1. 引包</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建你服务器应用程序</span></span><br><span class="line"><span class="comment">//    也就是原来的 http.createServer</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 基本路由</span></span><br><span class="line"><span class="comment">//在express中根据路径返回资源的时候不需要再根据url判断了，可以直接像下面这样写：</span></span><br><span class="line"><span class="comment">// 当服务器收到 get 请求 / 的时候，执行回调处理函数</span></span><br><span class="line"><span class="comment">// 在express中无需再去加content-type:text/html;utf-8等信息，他会自动去加上这些信息</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8" /&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;hello Express！你好&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 Express 中可以直接 req.query 来获取查询字符串参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.query)</span><br><span class="line">  res.send(<span class="string">'你好，我是 Express!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 .启动服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app is running at port 3000.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 静态服务</span></span><br><span class="line">app.use(<span class="string">'/public/'</span>, express.static(<span class="string">'./public/'</span>))</span><br><span class="line">app.use(<span class="string">'/static/'</span>, express.static(<span class="string">'./static/'</span>))</span><br><span class="line"><span class="comment">//当省略第一个参数的时候，直接通过localhost:3000/index.html来访问(实际上index.html是放在public目录下的)</span></span><br><span class="line">app.use(express.static(<span class="string">'./public/'</span>))</span><br><span class="line"><span class="comment">//相当于给public目录取了一个别名叫a ，可以通过localhost:3000/a/index.html来访问  </span></span><br><span class="line">app.use(<span class="string">'/a/'</span>,express.static(<span class="string">'./public/'</span>))</span><br></pre></td></tr></table></figure><h4 id="1-2-3-修改自动重启node服务器"><a href="#1-2-3-修改自动重启node服务器" class="headerlink" title="1.2.3 修改自动重启node服务器"></a>1.2.3 修改自动重启node服务器</h4><p>使用第三方工具nodemon来帮我们解决修改完代码频繁重启服务器的功能</p><p>​    nodemon是node.js开发的第三方命令行工具，使用下面命令可以安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --global nodemon</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用nodemon开启node服务器，一旦文件发生变化，nodemon会自动重启服务器</span></span><br><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure><h3 id="1-3-app-method方法的使用"><a href="#1-3-app-method方法的使用" class="headerlink" title="1.3 app.method方法的使用"></a>1.3 app.method方法的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一个请求的处理都会由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下：</span></span><br><span class="line">app.method(path, [callback...], callback)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    app：express 对象的一个实例</span></span><br><span class="line"><span class="comment">    method： HTTP 请求方法</span></span><br><span class="line"><span class="comment">    path:服务器上的路径</span></span><br><span class="line"><span class="comment">    callback:当路由匹配时要执行的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="1-3-1-请求方式"><a href="#1-3-1-请求方式" class="headerlink" title="1.3.1 请求方式"></a>1.3.1 请求方式</h4><p>​    Express支持的请求方式：get   post  put  delete。使用postman软件来测试四中请求方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"><span class="comment">//定义get请求下的/路径的处理函数</span></span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">app.get(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交数据</span></span><br><span class="line">app.post(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">app.put(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">app.delete(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何method的请求下的register处理函数</span></span><br><span class="line">app.all(<span class="string">"/register"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h4 id="1-3-2-请求路径"><a href="#1-3-2-请求路径" class="headerlink" title="1.3.2 请求路径"></a>1.3.2 请求路径</h4><p>​    路由的请求路径可以是字符串、字符串模式或者正则表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ?表示可有可无</span></span><br><span class="line"><span class="comment">// 匹配 acd 和 abcd</span></span><br><span class="line">app.get(<span class="string">'/ab?cd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'ab?cd'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?表示可有可无</span></span><br><span class="line"><span class="comment">// 匹配 /abe 和 /abcde</span></span><br><span class="line">app.get(<span class="string">'/ab(cd)?e'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> res.send(<span class="string">'ab(cd)?e'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则  匹配student的学号  \/ :转义/    小括号中的表示参数</span></span><br><span class="line">app.get(<span class="regexp">/^\/student\/([\d]&#123;6&#125;)$/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"学生信息，学号"</span> + req.params[<span class="number">0</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒号的方式，推荐使用</span></span><br><span class="line">app.get(<span class="string">"/student/:id"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = req.params[<span class="string">"id"</span>];</span><br><span class="line">    <span class="keyword">var</span> reg= <span class="regexp">/^[\d]&#123;6&#125;$/</span>;   <span class="comment">//正则验证</span></span><br><span class="line">    <span class="keyword">if</span>(reg.test(id))&#123;</span><br><span class="line">        res.send(id);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">"请检查格式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-3-3-请求处理函数"><a href="#1-3-3-请求处理函数" class="headerlink" title="1.3.3 请求处理函数"></a>1.3.3 请求处理函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//给路由指定两个处理函数</span></span><br><span class="line">    app.get(<span class="string">'/example/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'response will be sent by the next function ...'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      res.send(<span class="string">'Hello from B!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-app-use"><a href="#1-3-4-app-use" class="headerlink" title="1.3.4 app.use"></a>1.3.4 app.use</h4><p>​    app.use()与app.get()、app.post()不同的是，他的网址不是精确匹配的，可以有多个子路径。比如请求网址<a href="http://127.0.0.1:3000/admin/aa/bb/cc/dd能匹配到app.use(&quot;/admin&quot;,function(req,res){}" target="_blank" rel="noopener">http://127.0.0.1:3000/admin/aa/bb/cc/dd能匹配到app.use(&quot;/admin&quot;,function(req,res){}</a>)</p><p>​    app.use()可以挂在Router对象，app.get()、app.post()不可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">"/admin"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123; </span><br><span class="line">    res.write(req.originalUrl + <span class="string">"\n"</span>);   <span class="comment">//    /admin/aa/bb/cc/dd</span></span><br><span class="line">    res.write(req.baseUrl + <span class="string">"\n"</span>);  <span class="comment">//   /admin</span></span><br><span class="line">    res.write(req.path + <span class="string">"\n"</span>);   <span class="comment">//    /aa/bb/cc/dd</span></span><br><span class="line">    res.end(<span class="string">"你好"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不写路径的时候，实际上就相当于"/"，就是所有网址</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-4-Express路由和中间件"><a href="#1-4-Express路由和中间件" class="headerlink" title="1.4 Express路由和中间件"></a>1.4 Express路由和中间件</h3><h4 id="1-4-1-基本概念"><a href="#1-4-1-基本概念" class="headerlink" title="1.4.1 基本概念"></a>1.4.1 基本概念</h4><p>​    路由：就是如何处理HTTP请求中的路径部分。</p><p>​    中间件:就是在收到请求后和发送响应之前这个阶段执行的一些函数。</p><p>​    express应用其实就是由一系列顺序执行的Middleware中间件组成。</p><p>​    我们可以通过app.get()\app.post()等方法将路由和中间件绑定到一起，也可以使用app.use()方法将路由和中间件绑定到一起。</p><h4 id="1-4-2-Express中间件分类"><a href="#1-4-2-Express中间件分类" class="headerlink" title="1.4.2 Express中间件分类"></a>1.4.2 Express中间件分类</h4><h5 id="a-应用级中间件-使用use方法"><a href="#a-应用级中间件-使用use方法" class="headerlink" title="a) 应用级中间件 使用use方法"></a>a) 应用级中间件 使用use方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    app.use(<span class="string">"/admin"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setp1"</span>);</span><br><span class="line">        next();   <span class="comment">//next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.use(<span class="string">"/admin"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setp2"</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.use(<span class="string">"/admin"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setp2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setp1"</span>);</span><br><span class="line">        next();   <span class="comment">//next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setp2"</span>);</span><br><span class="line">        next();   <span class="comment">//next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f3 = <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setp3"</span>);</span><br><span class="line">        next();   <span class="comment">//next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.use(<span class="string">"/admin"</span>,[f1,f2,f3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-路由级中间件-使用get-post-put-delete等方法"><a href="#b-路由级中间件-使用get-post-put-delete等方法" class="headerlink" title="b) 路由级中间件 (使用get post put delete等方法)"></a>b) 路由级中间件 (使用get post put delete等方法)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义多个处理函数</span></span><br><span class="line">    <span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'CB0'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'CB1'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cb2 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      res.send(<span class="string">'Hello from C!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    app.get(<span class="string">'/example/c'</span>, [cb0, cb1, cb2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//定义多个处理函数</span></span><br><span class="line">    <span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'CB0'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'CB1'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    app.get(<span class="string">'/example/d'</span>, [cb0, cb1], <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'response will be sent by the next function ...'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      res.send(<span class="string">'Hello from D!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//next从下一个处理函数开始往下执行;next('router')，直接执行下一个相同路由。</span></span><br><span class="line">    app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res,next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        next(<span class="string">'route'</span>);</span><br><span class="line">        <span class="comment">//next();</span></span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res,next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res,next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-内置中间件"><a href="#c-内置中间件" class="headerlink" title="c) 内置中间件"></a>c) 内置中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">  </span><br><span class="line">app.use(<span class="string">'/public/'</span>, express.static(<span class="string">'./public/'</span>))</span><br></pre></td></tr></table></figure><h5 id="d-错误处理中间件"><a href="#d-错误处理中间件" class="headerlink" title="d) 错误处理中间件"></a>d) 错误处理中间件</h5><p>​    错误处理中间件总是需要<strong>四个参数</strong>。您必须提供四个参数以将其标识为错误处理中间件函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">"/admin"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr.name);</span><br><span class="line">        <span class="comment">//如果没有错误，交由下一个路由</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"x"</span>);</span><br><span class="line">        <span class="comment">//如果出现错误，交由错误处理中间件完成错误处理</span></span><br><span class="line">        next(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="e-第三方中间件"><a href="#e-第三方中间件" class="headerlink" title="e) 第三方中间件"></a>e) 第三方中间件</h5><p>​    有关第三方中间件，这里我们分析几个比较重要和常用的，知道这几个的使用，其它的也就会了。</p><p>​    <a href="http://www.expressjs.com.cn/resources/middleware.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/resources/middleware.html</a></p><p>​    body-parser ：解析body中的数据，并将其保存为Request对象的body属性。</p><p>​    cookie-parser ：解析客户端cookie中的数据，并将其保存为Request对象的cookie属性</p><p>​    express-session ：解析服务端生成的sessionid对应的session数据，并将其保存为Request对象的session属性</p><p>​    query：这个中间件将一个查询字符串从URL转换为JS对象，并将其保存为Request对象的query属性。这个中间件在第四个版本中已经内置了无需安装。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6的介绍</title>
      <link href="/2018/06/28/ES6%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/06/28/ES6%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6介绍"><a href="#ES6介绍" class="headerlink" title="ES6介绍"></a>ES6介绍</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript <span class="number">6.0</span>（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 <span class="number">2015</span> 年 <span class="number">6</span> 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</span><br><span class="line">ES6 提供了许多新特性，但并不是所有的浏览器都能够完美支持。好在目前各大浏览器自身也加快速度兼容 ES6 的新特性，其中对 ES6 新特性最友好的是 Chrome 和 Firefox 浏览器。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="ES6的兼容性"><a href="#ES6的兼容性" class="headerlink" title="ES6的兼容性"></a>ES6的兼容性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一、桌面端浏览器对ES2015的支持情况</span><br><span class="line">Chrome：<span class="number">51</span> 版起便可以支持 <span class="number">97</span>% 的 ES6 新特性。</span><br><span class="line">Firefox：<span class="number">53</span> 版起便可以支持 <span class="number">97</span>% 的 ES6 新特性。</span><br><span class="line">Safari：<span class="number">10</span> 版起便可以支持 <span class="number">99</span>% 的 ES6 新特性。</span><br><span class="line">IE：Edge <span class="number">15</span>可以支持 <span class="number">96</span>% 的 ES6 新特性。Edge <span class="number">14</span> 可以支持 <span class="number">93</span>% 的 ES6 新特性。（IE7~<span class="number">11</span> 基本不支持 ES6）</span><br><span class="line"></span><br><span class="line">二、移动端浏览器对ES2015的支持情况</span><br><span class="line">iOS：<span class="number">10.0</span> 版起便可以支持 <span class="number">99</span>% 的 ES6 新特性。</span><br><span class="line">Android：基本不支持 ES6 新特性（<span class="number">5.1</span> 仅支持 <span class="number">25</span>%）</span><br><span class="line"></span><br><span class="line">三、服务器对ES2015的支持情况</span><br><span class="line">Node.js：<span class="number">6.5</span> 版起便可以支持 <span class="number">97</span>% 的 ES6 新特性。（<span class="number">6.0</span> 支持 <span class="number">92</span>%）</span><br><span class="line"></span><br><span class="line">附：如何使用ES6的新特性，又能保证浏览器的兼容？</span><br><span class="line">针对 ES6 的兼容性问题，很多团队为此开发出了多种语法解析转换工具，把我们写的 ES6 语法转换成 ES5，相当于在 ES6 和浏览器之间做了一个翻译官。比较通用的工具方案有 babel，jsx，traceur，es6-shim 等。</span><br></pre></td></tr></table></figure><h3 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h3><h4 id="变量声明let与const"><a href="#变量声明let与const" class="headerlink" title="变量声明let与const"></a>变量声明let与const</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 1. let  变量</span><br><span class="line"><span class="comment">//1.1 let声明的变量不存在预解析</span></span><br><span class="line"><span class="comment">//1.2 let声明的变量在同一个作用域内不允许重复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之前作用域包含：全局作用域和函数作用域，不存在块级作用域。在ES6引入了块级作用域。</span></span><br><span class="line"><span class="comment">//所谓块级作用域就是  &#123; &#125; </span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//块级作用域内的变量不可以被外部访问</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环()中用let声明的变量只能在循环体内使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//无法访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.3 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   tmp = <span class="string">'abc'</span>; <span class="comment">// 暂时性死区</span></span><br><span class="line">   <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2. const  常量</span><br><span class="line"><span class="keyword">const</span>  a = <span class="number">1</span>;   <span class="comment">//const声明的常量必须初始化</span></span><br><span class="line">a = <span class="number">2</span>;  <span class="comment">//错误，a不可以被改变</span></span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.什么是解构赋值</span></span><br><span class="line">语法上就是赋值的作用。</span><br><span class="line">解构:左边一种结构，右边一种结构，左右一一对应进行赋值。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.数组的解构赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用解构赋值进行变量交换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b=<span class="number">2</span>;</span><br><span class="line">    [a,b] = [b,a];</span><br><span class="line">    <span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.返回多个参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> [a,b] = f();</span><br><span class="line">    <span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.对象的解构赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;foo,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'hello'</span>,<span class="attr">bar</span>:<span class="string">'hi'</span>&#125;;</span><br><span class="line">    <span class="comment">//给对象取别名(如果有了别名，那么原来的名字就无效了)</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">foo</span>:abc,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'hello'</span>,<span class="attr">bar</span>:<span class="string">'hi'</span>&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(foo,bar);</span><br><span class="line">    <span class="comment">//将对象中的属性赋值给对应成员</span></span><br><span class="line">    <span class="keyword">let</span> &#123;cos,sin,random&#125; = <span class="built_in">Math</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(cos,sin,random);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.对象的解构赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> metaData=&#123;</span><br><span class="line">        title:<span class="string">"abc"</span>,</span><br><span class="line">        test:[&#123;</span><br><span class="line">            title:<span class="string">"test"</span>,</span><br><span class="line">            desc:<span class="string">"description"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">title</span>:esTitle,<span class="attr">test</span>:[&#123;<span class="attr">title</span>:cnTitle&#125;]&#125; = meatData;</span><br><span class="line">    <span class="built_in">console</span>.log(esTitle,cnTitle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.字符串的解构赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a,b,c,d,e] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c,d,e);</span><br><span class="line">    <span class="comment">//获取字符串长度</span></span><br><span class="line">    <span class="keyword">let</span> &#123;length&#125; = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//常用方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>.includes(<span class="string">"world"</span>,<span class="number">3</span>));  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>.startsWidth(<span class="string">"h"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>.endsWith(<span class="string">"d"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字符串复制</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str.repeat(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//模板字符串  反引号</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        name:<span class="string">"zhangsan"</span>,</span><br><span class="line">        age:<span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">gender</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">`姓名<span class="subst">$&#123;obj.name&#125;</span>,年龄<span class="subst">$&#123;obj.age&#125;</span>,性别<span class="subst">$&#123;fn(<span class="string">'男'</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前补后补字符串</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>.padStart(<span class="number">2</span>,<span class="string">"0"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>.padEnd(<span class="number">2</span>,<span class="string">"0"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//标签模板字符串</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s,v1,v2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(s);  <span class="comment">//字符串模板，数组</span></span><br><span class="line">        <span class="built_in">console</span>.log(v1);<span class="comment">//第一个$&#123;a+b&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(v2);<span class="comment">//第二个$&#123;a*b&#125;</span></span><br><span class="line">        <span class="comment">//通过手动return 来过滤字符串</span></span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]+v1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(tag<span class="string">`Hello <span class="subst">$&#123;a+b&#125;</span> world <span class="subst">$&#123;a*b&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.参数默认值(带有默认值的参数需要放在无默认值参数的右边)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">param = <span class="string">'hello'</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param);</span><br><span class="line">    &#125;</span><br><span class="line">    foo();</span><br><span class="line">    foo(<span class="string">"你好"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.参数结构赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;uname=<span class="string">'lisi'</span>,age=<span class="number">13</span>&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(uname,age);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(&#123;<span class="attr">uname</span>:<span class="string">'zhangsan'</span>,age<span class="string">"15"</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.rest参数  (剩余参数)  ...  将多个参数变成数组</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,...param</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a,param);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.扩展运算符  ...  将数组变为离散值</span></span><br><span class="line">    <span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> arr3 = [...arr1,...arr2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.扩展运算符  ...  将数组变为多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,c,</span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(a+b+c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    foo.apply(<span class="literal">null</span>,arr);</span><br><span class="line">    foo(...arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//6.箭头函数   代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">"hello"</span>)&#125;;</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> foo2 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>+name +c);</span><br><span class="line">    &#125;;</span><br><span class="line">    foo2(<span class="string">"小明"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.箭头函数应用</span></span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">element,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element,index);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.箭头函数的注意事项：</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//8.1 箭头函数中的this是定义函数是所在的执行环境</span></span><br><span class="line">        <span class="comment">//setTimeout中使用了箭头函数，箭头函数中引用this实际上是调用的是定义时的上一层作用域的this</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    foo.call(&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.2 箭头函数不可以使用arguments获取参数列表，可以用reset参数替代</span></span><br><span class="line">    <span class="comment">//   箭头函数不能new，没有原型链</span></span><br><span class="line">    <span class="keyword">let</span> foo = <span class="function">(<span class="params">...param</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.3 如果箭头函数中没有形参，()不能省略</span></span><br><span class="line">    <span class="comment">//8.4 如果箭头函数中只有一条return语句，可以省略&#123;&#125;和return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.from  方法从一个类似数组或可迭代对象中创建一个新的数组实例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//去数组中的重复元素</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">        <span class="built_in">console</span>.log(arr1);<span class="comment">//输出：12,13,11,0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取数组的所有key</span></span><br><span class="line">    [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>].keys();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组的所有values </span></span><br><span class="line">    [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>].values();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有的key和value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [index,value] <span class="keyword">of</span> [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>].entries()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(index,value);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组查找</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="keyword">return</span> item&gt;<span class="number">3</span>&#125;))</span><br><span class="line">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="keyword">return</span> item&gt;<span class="number">3</span>&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组包含</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="number">1</span>));</span><br><span class="line">     <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.es5对象和es6对象对比</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> o = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//es5</span></span><br><span class="line">    <span class="keyword">let</span> es5 = &#123;</span><br><span class="line">        o:o,</span><br><span class="line">        k:k,</span><br><span class="line">        say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//es6</span></span><br><span class="line">    <span class="keyword">let</span> es6 = &#123;</span><br><span class="line">        o,</span><br><span class="line">        k,</span><br><span class="line">        say()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"say"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(es5,es6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.属性表达式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="string">"b"</span>;</span><br><span class="line">    <span class="keyword">let</span> es5_obj = &#123;</span><br><span class="line">        a:<span class="string">"c"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> es6_obj=&#123;</span><br><span class="line">        <span class="comment">//这里的[a]这个值为上面的b</span></span><br><span class="line">        [a]:<span class="string">"c"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.新增API</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Object.is 相当于===</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">"abc"</span>,<span class="string">"abc"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//浅拷贝</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(&#123;<span class="attr">a</span>:<span class="string">"a"</span>&#125;,&#123;<span class="attr">b</span>:<span class="string">"b"</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历对象</span></span><br><span class="line">    <span class="keyword">let</span> test = &#123;<span class="attr">k</span>:<span class="number">123</span>,<span class="attr">o</span>:<span class="number">456</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(test))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log([key,value]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>​    ES6中新增了Symbol数据类型。Symbol不可以new</p><p>​    之前的基本数据类型有6种：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>​    Symbol声明的变量是唯一的，意义在于减少命名冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Symbol的变量是唯一的，所以a1和a2永远不相等</span></span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="keyword">let</span> a2 = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(a1 === a2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Symbol全局注册表是一个类似全局作用域的共享环境</span></span><br><span class="line">    <span class="comment">//Symbol.for()方法首先在全局Symbol注册表中搜索键为"a3"的Symbol是否存在，如果存在，直接返回已有的Symbol；否则，创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。后续如果再传入同样的键调用Symbol.for()会返回相同的Symbol</span></span><br><span class="line">    <span class="keyword">let</span> a3 = <span class="built_in">Symbol</span>.for(<span class="string">"a3"</span>);</span><br><span class="line">    <span class="keyword">let</span> a4 = <span class="built_in">Symbol</span>.for(<span class="string">"a3"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a3 === a4);  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Symbol作为key</span></span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="built_in">Symbol</span>.for(<span class="string">"abc"</span>);</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        [a1]:<span class="string">"123"</span>,</span><br><span class="line">        <span class="string">"abc"</span>:<span class="number">345</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">    <span class="comment">//通过之前的遍历方式无法获取Symbol声明的key</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log([key,value]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过getOwnPropertySymbols获取Symbol的信息（仅仅获取Symbol的信息）</span></span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertySymbols(obj).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(obj[item]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Symbol作用：</span></span><br><span class="line">    <span class="comment">//有时我们可能希望在不同的代码中共享同一个Symbol，例如，在你的应用中有两种不同的对象类型，但是你希望它们使用同一个Symbol属性来表示一个独特的标识符。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a1 = <span class="built_in">Symbol</span>.for(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            [a1]:<span class="string">"123"</span>,</span><br><span class="line">            <span class="string">"abc"</span>:<span class="number">345</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里拿到的Symbol和上面一个代码块拿到的Symbol是同一个东西</span></span><br><span class="line">        <span class="keyword">let</span> a1 = <span class="built_in">Symbol</span>.for(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">            [a1]:<span class="string">"123"</span>,</span><br><span class="line">            <span class="string">"abc"</span>:<span class="number">34544</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6数据结构"><a href="#ES6数据结构" class="headerlink" title="ES6数据结构"></a>ES6数据结构</h3><h4 id="Array和Set"><a href="#Array和Set" class="headerlink" title="Array和Set"></a>Array和Set</h4><h5 id="a-Array"><a href="#a-Array" class="headerlink" title="a) Array"></a>a) Array</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   let  arr = [1,2,3]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-Set"><a href="#b-Set" class="headerlink" title="b) Set"></a>b) Set</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Set元素是唯一</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">7</span>);</span><br><span class="line">    list.add(<span class="string">"a"</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Set的方法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> arr=[<span class="string">'add'</span>,<span class="string">'delete'</span>,<span class="string">'clear'</span>,<span class="string">'has'</span>];</span><br><span class="line">  <span class="keyword">let</span> list=<span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'has'</span>,list.has(<span class="string">'add'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'delete'</span>,list.delete(<span class="string">'add'</span>),list);</span><br><span class="line">  list.clear();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'list'</span>,list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Set的遍历</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> arr=[<span class="string">'add'</span>,<span class="string">'delete'</span>,<span class="string">'clear'</span>,<span class="string">'has'</span>];</span><br><span class="line">  <span class="keyword">let</span> list=<span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line"></span><br><span class="line">  list.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="built_in">console</span>.log(item);&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.Set转Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">7</span>);</span><br><span class="line">    list.add(<span class="string">"a"</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> arr = [...list];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-WeakSet"><a href="#c-WeakSet" class="headerlink" title="c) WeakSet"></a>c) WeakSet</h5><p>​    WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有下面区别。</p><blockquote><p>1.WeakSet 的成员只能是对象，而不能是其他类型的值。</p><p>2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>3.WeakSet 只有add/delete/clear/has三个方法，不能遍历，没有size属性等</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> weakList=<span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">  <span class="keyword">let</span> arg=&#123;&#125;;</span><br><span class="line">  weakList.add(arg);</span><br><span class="line">  <span class="comment">// weakList.add(2);</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'weakList'</span>,weakList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d-Array和Set对比"><a href="#d-Array和Set对比" class="headerlink" title="d) Array和Set对比"></a>d) Array和Set对比</h5><blockquote><p>1.在Set中我们不能像访问数组元素那样直接通过索引来访问集合中的元素，如有需要，需要先将Set转换为数组。<br>2.Array中的数组元素是可以重复的，Set中的数组元素不能重复<br>3.Array的key默认是索引值，value是数组内容；Set的key和value都是实际内容</p></blockquote><h4 id="Object和Map"><a href="#Object和Map" class="headerlink" title="Object和Map"></a>Object和Map</h4><h5 id="a-Object"><a href="#a-Object" class="headerlink" title="a) Object"></a>a) Object</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        key:<span class="string">"value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-Map"><a href="#b-Map" class="headerlink" title="b) Map"></a>b) Map</h5><p>​    Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//基本使用</span></span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> arr=[<span class="string">'123'</span>];</span><br><span class="line">  map.set(arr,<span class="number">456</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'map'</span>,map,map.get(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//Map的第二种定义</span></span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">123</span>],[<span class="string">'b'</span>,<span class="number">456</span>]]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'map args'</span>,map);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'size'</span>,map.size);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'delete'</span>,map.delete(<span class="string">'a'</span>),map);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'clear'</span>,map.clear(),map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//has(key),delete(key),clear()</span></span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    m.set(<span class="string">'edition'</span>, <span class="number">6</span>);</span><br><span class="line">    m.set(<span class="number">262</span>, <span class="string">'standard'</span>);</span><br><span class="line">    m.set(<span class="literal">undefined</span>, <span class="string">'nah'</span>);</span><br><span class="line"></span><br><span class="line">    m.has(<span class="string">'edition'</span>)     <span class="comment">// true</span></span><br><span class="line">    m.has(<span class="string">'years'</span>)       <span class="comment">// false</span></span><br><span class="line">    m.has(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">    m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m.delete(<span class="literal">undefined</span>)</span><br><span class="line">    m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Map的遍历  Map遍历的顺序就是插入的顺序</span></span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">      [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">      [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//for ... of 可以遍历Array、Set、Map不能遍历Object </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-WeakMap"><a href="#c-WeakMap" class="headerlink" title="c) WeakMap"></a>c) WeakMap</h5><blockquote><p>1.WeakMap的key值只能是对象，而不能是其他类型的值。</p><p>2.WeakMap中的key值都是弱引用</p><p>3.WeakMap不能遍历，没有size属性等</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> weakmap=<span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> o=&#123;&#125;;</span><br><span class="line">  weakmap.set(o,<span class="number">123</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(weakmap.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d-Object和Map区别"><a href="#d-Object和Map区别" class="headerlink" title="d) Object和Map区别"></a>d) Object和Map区别</h5><blockquote><ol><li>一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。<br>2.Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map对象是按插入的顺序返回键值。</li><li>通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li><li>Map 是可迭代的，而 Object 的迭代需要先获取它的键数组然后再进行迭代。</li><li>Map 在频繁增删键值对的场景下会有些性能优势。</li></ol></blockquote><h3 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h3><h4 id="Proxy介绍"><a href="#Proxy介绍" class="headerlink" title="Proxy介绍"></a>Proxy介绍</h4><p>​    Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(target, handler);</span><br><span class="line">参数一target：目标对象，即拦截目标，可以是原生对象或者内置对象（比如是Object或者其他）；</span><br><span class="line">参数二handler：拦截配置。你对参数一拦截哪些属性，拦截后的操作如何，都是在这里配置的；</span><br><span class="line">返回值p：返回代理对象。需要注意，p和target并不相等。对返回值p进行的操作，会触发handler中自定义的方法。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> person=&#123;</span><br><span class="line">        time:<span class="string">'2017-03-11'</span>,</span><br><span class="line">        name:<span class="string">'小明'</span>,</span><br><span class="line">        age:<span class="number">18</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> monitor=<span class="keyword">new</span> <span class="built_in">Proxy</span>(person,&#123;</span><br><span class="line">        <span class="comment">// 拦截对象属性的读取</span></span><br><span class="line">        <span class="keyword">get</span>(target,key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key === <span class="string">"name"</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"不告诉你"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target[key];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拦截对象设置属性</span></span><br><span class="line">        <span class="keyword">set</span>(target,key,value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key===<span class="string">'time'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> target[key]=value;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> target[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拦截key in object操作</span></span><br><span class="line">        has(target,key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key===<span class="string">'name'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> target[key]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拦截delete</span></span><br><span class="line">        deleteProperty(target,key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key === <span class="string">"age"</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> target[key];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 拦截Object.keys,Object.getOwnPropertySymbols,Object.getOwnPropertyNames</span></span><br><span class="line">        ownKeys(target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.keys(target).filter(<span class="function"><span class="params">item</span>=&gt;</span>item!=<span class="string">'time'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接访问name。会被拦截</span></span><br><span class="line">    <span class="built_in">console</span>.log(monitor.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改time成功，修改age被拦截</span></span><br><span class="line">    monitor.time=<span class="string">'2018'</span>;</span><br><span class="line">    monitor.age= <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(monitor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name值为true，time值为false 被拦截了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> monitor,<span class="string">'time'</span> <span class="keyword">in</span> monitor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//age被删除，name不被删除</span></span><br><span class="line">    <span class="keyword">delete</span> monitor.age;</span><br><span class="line">    <span class="keyword">delete</span> monitor.name;</span><br><span class="line">    <span class="built_in">console</span>.log(monitor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为写了ownKeys的拦截，此时所有的time都不会被打印</span></span><br><span class="line">    <span class="built_in">console</span>.log(monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Proxy实现对象属性值的校验"><a href="#Proxy实现对象属性值的校验" class="headerlink" title="Proxy实现对象属性值的校验"></a>Proxy实现对象属性值的校验</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">    name:<span class="string">'dog'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> monitor=<span class="keyword">new</span> <span class="built_in">Proxy</span>(animal,&#123;</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value) &#123;</span><br><span class="line">        <span class="comment">//animalValidator中对应属性的校验逻辑是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (animalValidator[key]) &#123;</span><br><span class="line">            <span class="comment">//调用animalValidator对应属性的校验方法，入参属性值，如果条件满足</span></span><br><span class="line">            <span class="keyword">if</span> (animalValidator[key](value)) &#123;</span><br><span class="line">                target[key] = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`Cannot set <span class="subst">$&#123;key&#125;</span> to <span class="subst">$&#123;value&#125;</span>. Invalid.`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验逻辑</span></span><br><span class="line"><span class="keyword">var</span> animalValidator = &#123;</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 动物的名字必须是字符串类型的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> name === <span class="string">'string'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">monitor.name = <span class="string">'dog'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(monitor.name);</span><br><span class="line"><span class="comment">// Uncaught Error: Cannot set name to 123. Invalid.</span></span><br><span class="line">monitor.name = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>​    反射机制是指程序在运行的时候访问、检测和修改它本身状态或行为的一种能力，例如一个对象能够在运行时知道自己有哪些方法和属性。</p><p>​    反射的概念在编译型的编程语言中比较明显，比如java、C#、Object-c等。对于     <code>JavaScript</code>来说，反射就是获取对象的内部结构的信息，所以JS中的反射随处可见，比如for…in方式遍历对象。</p><p>​    从ECMAScript6开始，JS引入Reflect这个API专门用于操作反射。</p><p>​    Reflect引入的目的主要有下面几个：</p><h5 id="a-抽取语言内部的方法"><a href="#a-抽取语言内部的方法" class="headerlink" title="a) 抽取语言内部的方法"></a>a) 抽取语言内部的方法</h5><p>​    从ECMAScript6开始，JS将Object对象的一些明显属于语言内部的方法（ 比如Object.defineProperty）放到Reflect对象上。 现阶段某些方法同时在Object和Reflect对象上部署， 未来的新方法将只部署在Reflect对象上。并且修改某些 Object 方法的返回结果， 让其变得更合理。 比如， Object.defineProperty(obj, name, desc) 在无法定义属性时， 会抛出一个错误，而Reflect.defineProperty(obj, name, desc) 则会返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  新写法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-让Object操作都变成函数行为。"><a href="#c-让Object操作都变成函数行为。" class="headerlink" title="c) 让Object操作都变成函数行为。"></a>c) 让Object操作都变成函数行为。</h5><p>​     某些Object操作是命令式， 比如name in obj和delete obj[name]，而Reflect.has(obj, name) 和Reflect.deleteProperty(obj, name) 让它们变成了函数行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  老写法</span></span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">//  新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="c-Proxy和Reflect结合使用"><a href="#c-Proxy和Reflect结合使用" class="headerlink" title="c) Proxy和Reflect结合使用"></a>c) Proxy和Reflect结合使用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line"><span class="keyword">get</span>(target, name) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);</span><br><span class="line">&#125;,</span><br><span class="line">deleteProperty(target, name) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);</span><br><span class="line">&#125;,</span><br><span class="line">has(target, name) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'has'</span> + name);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="d-代码可读性更好"><a href="#d-代码可读性更好" class="headerlink" title="d) 代码可读性更好"></a>d) 代码可读性更好</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#1. Reflect.apply()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//Math的min只能获取指定参数中的最小值，要获取指定数组中的最小值，这个方法就不行了。</span></span><br><span class="line">    <span class="built_in">Math</span>.min(<span class="number">10</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要获取数组中的最小值，我们可以使用Math.min.apply(thisArg,[params])方法，apply()方法两个参数，第一个用作修改调用函数中的this指向，第二个给指定函数传递参数(数组)</span></span><br><span class="line">    <span class="keyword">var</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line">    <span class="keyword">var</span> youngest = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, ages);  </span><br><span class="line">    <span class="keyword">var</span> oldest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, ages);  </span><br><span class="line">    <span class="comment">//输出youngest的类型</span></span><br><span class="line">    <span class="keyword">var</span> type = <span class="built_in">Object</span>.prototype.toString.call(youngest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上是之前的解决方案，有了反射之后，我们可以使用Reflect.apply()方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Reflect.apply()方法有三个参数：</span></span><br><span class="line"><span class="comment">    　 第一个参数为： 需要执行的函数；</span></span><br><span class="line"><span class="comment">　　 第二个参数为： 需要执行函数的上下文this；</span></span><br><span class="line"><span class="comment">　 　第三个参数为： 是一个数组或者伪数组， 会作为执行函数的参数；</span></span><br><span class="line"><span class="comment">　 */</span></span><br><span class="line">    <span class="keyword">var</span> youngest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>, ages);  </span><br><span class="line">    <span class="keyword">var</span> oldest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.max, <span class="built_in">Math</span>, ages);  </span><br><span class="line">    <span class="keyword">var</span> type = <span class="keyword">var</span> type = <span class="built_in">Reflect</span>.apply(<span class="built_in">Object</span>.prototype.toString, youngest , [youngest]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#2. Symbol的问题</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        [a1]:<span class="string">"123"</span>,</span><br><span class="line">        <span class="string">"abc"</span>:<span class="number">345</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时我们通过for...in方式无法获取到Symbol声明的字段信息。</span></span><br><span class="line">    <span class="comment">//通过 Object.getOwnPropertySymbols(obj).forEach 又仅仅只能获取Symbol字段的信息，怎么办呢？</span></span><br><span class="line">    #2.1.解决方案1</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj).concat(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line"></span><br><span class="line">    #2.2.解决方案2，使用反射。ownKeys获取指定对象的所有key(不包含继承)</span><br><span class="line">    <span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(obj[item]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>​    ES6引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看做只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h4 id="类的定义和创建实例"><a href="#类的定义和创建实例" class="headerlink" title="类的定义和创建实例"></a>类的定义和创建实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6对js的类进行了规范：方法写在原型上，把属性写在构造函数里面</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 基本定义和生成实例</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name='mukewang')&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    showMsg()&#123;    <span class="comment">//定义在原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> v_parent=<span class="keyword">new</span> Parent(<span class="string">'v'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'构造函数和实例'</span>,v_parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 继承</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name='mukewang')&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'继承'</span>,<span class="keyword">new</span> Child());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 继承传递参数</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name='mukewang')&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name='child')&#123;</span><br><span class="line">      <span class="comment">//先初始化父亲的信息，在初始化自己的信息  </span></span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      <span class="keyword">this</span>.type=<span class="string">'child'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'继承传递参数'</span>,<span class="keyword">new</span> Child(<span class="string">'hello'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getter和setter方法的作用：给成员变量赋值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">//访问set name()方法</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;         <span class="comment">//由于age没有get和set方法，所以这里直接给age成员变量赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> name (name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setter"</span>);</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> name () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"getter"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"zhang"</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p._name);     <span class="comment">//访问真实成员变量_name</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name);      <span class="comment">//访问get  name()方法，在这个方法中再去访问真实成员变量_name</span></span><br><span class="line"></span><br><span class="line">#getter和setter注意点：</span><br><span class="line"><span class="number">1.</span>一旦某个属性写了getter和setter方法，则在使用<span class="keyword">this</span>.xxx,p.xxx的时候都是去访问getter和setter方法</span><br><span class="line"><span class="number">2.</span>一旦某个属性写了getter和setter方法，真实的成员变量就不在是xxx了，而是_xxx</span><br><span class="line"><span class="number">3.</span>getter和setter方法要写就都一起写上</span><br><span class="line"><span class="number">4.</span>getter和setter方法中注意死循环的问题</span><br></pre></td></tr></table></figure><h4 id="静态方法和静态属性"><a href="#静态方法和静态属性" class="headerlink" title="静态方法和静态属性"></a>静态方法和静态属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法和静态属性：属于类/函数的信息，可以直接通过类名和函数名直接访问，不需要创建对象</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name='mukewang')&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> tell()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'tell'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.tell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name='mukewang')&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> tell()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'tell'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Parent.type=<span class="string">'test'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'静态属性'</span>,Parent.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="使用异步回调"><a href="#使用异步回调" class="headerlink" title="使用异步回调"></a>使用异步回调</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  fs.readFile(<span class="string">'./data/b.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    fs.readFile(<span class="string">'./data/c.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"># 回调的问题：回调地狱，回调的层次太深，代码很难维护</span><br></pre></td></tr></table></figure><h4 id="使用Promise"><a href="#使用Promise" class="headerlink" title="使用Promise"></a>使用Promise</h4><h5 id="a-Promise介绍"><a href="#a-Promise介绍" class="headerlink" title="a) Promise介绍"></a>a) Promise介绍</h5><p>​    所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">#1.通过打印顺序我们可以发现 1--&gt;2--&gt;3 --&gt;"aaa"</span><br><span class="line">#2. Promise本身不是异步的，只是Promise中的任务是异步的</span><br><span class="line">#3. Promise中第一个参数的function是new之后就立刻执行的</span><br></pre></td></tr></table></figure><h5 id="b-Promise的状态"><a href="#b-Promise的状态" class="headerlink" title="b) Promise的状态"></a>b) Promise的状态</h5><p>​    Promise有三种状态：</p><blockquote><ul><li>Pending（进行中、未完成的）</li><li>Resolved（已完成，又称 Fulfilled）</li><li>Rejected（已失败）。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="comment">//异步任务完毕，修改Promise状态，向下一个then传递数据</span></span><br><span class="line">            reject(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//then方法需要Promise对象来调用，表示异步任务执行完毕之后做的事情</span></span><br></pre></td></tr></table></figure><h5 id="c-Promise的链"><a href="#c-Promise的链" class="headerlink" title="c) Promise的链"></a>c) Promise的链</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"11111"</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"22222"</span>)</span><br><span class="line">        <span class="comment">//注意：如果此处返回的不是Promise对象，那么再后面一个then不会异步</span></span><br><span class="line">        <span class="comment">//要保证Promise的链式编程，需要在当前then中返回Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;, <span class="number">2000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3333'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="e-使用Promise读文件"><a href="#e-使用Promise读文件" class="headerlink" title="e) 使用Promise读文件"></a>e) 使用Promise读文件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#1.基本实现</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'./data/b.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'./data/c.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.代码封装</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filePath, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pReadFile(<span class="string">'./data/a.txt'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">'./data/b.txt'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">'./data/c.txt'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h5 id="f-Promise的异常捕获"><a href="#f-Promise的异常捕获" class="headerlink" title="f) Promise的异常捕获"></a>f) Promise的异常捕获</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> p1=<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行4'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">5</span>)&#123;</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1(<span class="number">6</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'log'</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'catch'</span>,err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    p1(<span class="number">3</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'log'</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'catch'</span>,err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="g-Promise-all和Promise-race"><a href="#g-Promise-all和Promise-race" class="headerlink" title="g) Promise.all和Promise.race"></a>g) Promise.all和Promise.race</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Promise.all   等所有的promise执行完了再执行then</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">"P1"</span>);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">"P2"</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Promise.race   有任何一个promise执行完了就执行then</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">"P1"</span>);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">"P2"</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-6-4-jquery中Promise"><a href="#2-6-4-jquery中Promise" class="headerlink" title="2.6.4 jquery中Promise"></a>2.6.4 jquery中Promise</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取数据"</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./lib/jquery/dist/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//请求本地数据</span></span></span><br><span class="line"><span class="javascript">          url: <span class="string">'./data.json'</span>,</span></span><br><span class="line"><span class="javascript">          type: <span class="string">'get'</span>,</span></span><br><span class="line"><span class="javascript">          dataType: <span class="string">'json'</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">          .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">          &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-7-Iterator"><a href="#2-7-Iterator" class="headerlink" title="2.7 Iterator"></a>2.7 Iterator</h3><h4 id="2-7-1-遍历方式的总结"><a href="#2-7-1-遍历方式的总结" class="headerlink" title="2.7.1 遍历方式的总结"></a>2.7.1 遍历方式的总结</h4><h5 id="a-普通for循环"><a href="#a-普通for循环" class="headerlink" title="a) 普通for循环"></a>a) 普通for循环</h5><p>​    自Javascript诞生起就一直用的 就是for循环，它用来遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt; arr.length ; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-forEach"><a href="#b-forEach" class="headerlink" title="b) forEach"></a>b) forEach</h5><p>​    从ES5开始 Javascript内置了forEach方法用来遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">val, idx, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val + <span class="string">', index = '</span> + idx) <span class="comment">// val是当前元素，index当前元素索引，arr数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//写法简单了很多，但是也存在一个局限 就是你不能中断循环(使用break语句或使用return语句）</span></span><br></pre></td></tr></table></figure><h5 id="c-for-in"><a href="#c-for-in" class="headerlink" title="c) for-in"></a>c) for-in</h5><p>​    for in更适合遍历对象，不要使用for in遍历数组，虽然for in也可以遍历数组，但是会存在以下问题：</p><p>​    1.index索引为字符串型数字，不能直接进行几何运算</p><p>​    2.遍历顺序有可能不是按照实际数组的内部顺序</p><p>​    3.使用for in会遍历数组所有的可枚举属性，包括原型。例如原型方法method和name属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="string">'1'</span>, <span class="attr">b</span>: <span class="string">'2'</span>, <span class="attr">c</span>: <span class="string">'3'</span>, <span class="attr">d</span>: <span class="string">'4'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o)    <span class="comment">//遍历的实际上是对象的属性名称 a,b,c,d</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[o])  <span class="comment">//这个才是属性对应的值1，2，3，4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d-for…of"><a href="#d-for…of" class="headerlink" title="d) for…of"></a>d) for…of</h5><p>​    它是ES6中新增加的语法,，主要用来循环实现了Iterator接口类型的对象。for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name。但是for…of不可以遍历对象，因为对象没有实现Iterator接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'China'</span>, <span class="string">'America'</span>, <span class="string">'Korea'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o) <span class="comment">//China, America, Korea</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h4><p>1.遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>2.Iterator的作用有三个：</p><p>​    一是为各种数据结构，提供一个统一的、简便的访问接口；</p><p>​    二是使得数据结构的成员能够按某种次序排列；</p><p>​    三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p><p>3.在ES6中，有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>4.在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterator基本使用</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">let</span> arr=[<span class="string">'hello'</span>,<span class="string">'world'</span>];</span><br><span class="line">      <span class="keyword">let</span> map=arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">      <span class="built_in">console</span>.log(map.next());</span><br><span class="line">      <span class="built_in">console</span>.log(map.next());</span><br><span class="line">      <span class="built_in">console</span>.log(map.next());</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//内部遍历的时候就使用了迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(item); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="给object添加迭代器"><a href="#给object添加迭代器" class="headerlink" title="给object添加迭代器"></a>给object添加迭代器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为object对象添加迭代器</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    data: [ <span class="string">'aaa'</span>, <span class="string">'bbb'</span> ],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self.data[index++],</span><br><span class="line">                        done: <span class="literal">false</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>​    在 ES6 出现之前，基本都是各式各样类似Promise的解决方案来处理异步操作的代码逻辑，但是 ES6 的Generator却给异步操作又提供了新的思路，马上就有人给出了如何用Generator来更加优雅的处理异步操作。</p><h4 id="Generator基本使用"><a href="#Generator基本使用" class="headerlink" title="Generator基本使用"></a>Generator基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Generator函数和普通的函数区别有两个， 1：function和函数名之间有一个*号， 2：函数体内部使用了yield表达式；比如这样：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = fibonacci();</span><br><span class="line"><span class="built_in">console</span>.log(it);          <span class="comment">// "Generator &#123;  &#125;"</span></span><br><span class="line"><span class="comment">//运行fibonacci()函数会返回一个Iterator实例， 然后再执行Iterator实例的next()方法， 那么这个函数才开始真正运行， 并把yield后面的值包装成固定对象并返回。</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());   <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//再调用一次Iterator实例的next()方法，执行fibonacci()函数的第二个yield，把第二个yield的值返回。以此类推，直到所有的yield执行完</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h4 id="循环与Generator"><a href="#循环与Generator" class="headerlink" title="循环与Generator"></a>循环与Generator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> obj=&#123;&#125;;</span><br><span class="line">  obj[<span class="built_in">Symbol</span>.iterator]=<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'value'</span>,value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#### </p><p>## </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AMD和CMD</title>
      <link href="/2018/05/04/AMD%E5%92%8CCMD/"/>
      <url>/2018/05/04/AMD%E5%92%8CCMD/</url>
      
        <content type="html"><![CDATA[<h4 id="AMD模块规范"><a href="#AMD模块规范" class="headerlink" title="AMD模块规范"></a>AMD模块规范</h4><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AMD ： Asynchronous Module Definition。AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</span><br><span class="line">#1.定义</span><br><span class="line">define(id?,dependencies?,factory);</span><br><span class="line">    - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字.</span><br><span class="line">    - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量</span><br><span class="line">    - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值.</span><br><span class="line">    - 默认情况下文件名即为模块名</span><br><span class="line"></span><br><span class="line">#2.导入</span><br><span class="line"><span class="built_in">require</span>([dependencies],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">    - 第一个参数是一个数组,表示所依赖的模块</span><br><span class="line">    - 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块</span><br></pre></td></tr></table></figure><h4 id="CMD模块规范"><a href="#CMD模块规范" class="headerlink" title="CMD模块规范"></a>CMD模块规范</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMD 即Common Module Definition通用模块定义,CMD规范是国内发展出来的</span><br><span class="line"></span><br><span class="line">#1. 定义</span><br><span class="line">define(id?,d?,factory)</span><br><span class="line">- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id</span><br><span class="line">- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖</span><br><span class="line">- factory :函数   <span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span></span><br><span class="line"><span class="function">        <span class="title">require</span> 是一个方法,用来获取其他模块提供的接口</span></span><br><span class="line"><span class="function">        <span class="title">exports</span> 是一个对象,用来向外提供模块接口</span></span><br><span class="line"><span class="function">        <span class="title">module</span> 是一个对象,上面存储了与当前模块相关联的一些属性和方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#2. 使用</span></span><br><span class="line"><span class="function"><span class="title">seajs</span>.<span class="title">use</span>(<span class="params"><span class="string">'mymodel.js'</span>,function(mymodel</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="AMD和CMD区别"><a href="#AMD和CMD区别" class="headerlink" title="AMD和CMD区别"></a>AMD和CMD区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>CMD 推崇依赖就近;AMD 推崇依赖前置</span><br><span class="line"><span class="number">2.</span>CMD 是延迟执行,懒加载;AMD 是提前执行</span><br><span class="line"><span class="number">3.</span>CMD性能好,因为只有用户需要的时候才执行;AMD用户体验好,因为没有延迟,依赖模块提前执行了</span><br><span class="line"></span><br><span class="line"># 总结：AMD和CMD最大的区别是对依赖模块的执行时机处理不同,注意不是加载的时机或者方式不同。两者都是异步加载模块。</span><br><span class="line"></span><br><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">      a.doSomething()</span><br><span class="line">      b.dosomething()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> a=<span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">      a.doSomethimg()</span><br><span class="line">      <span class="keyword">var</span> b=<span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line">      b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP的一些用法</title>
      <link href="/2018/04/17/PHP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"/>
      <url>/2018/04/17/PHP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是PHP"><a href="#什么是PHP" class="headerlink" title="什么是PHP"></a>什么是PHP</h3><p>PHP（PHP: Hypertext Preprocessor）是一种被广泛应用的脚本语言，它可以被嵌入到 HTML中，尤其适合做动态网站开发开发。</p><a id="more"></a><p>​    我们接下来会在 PHP 中看到的许多代码特性和其他编程语言类似，例如：变量、函数、循环，等等。 代码语法看起来不同，但是在概念上是基本类似的。</p><h3 id="PHP标记"><a href="#PHP标记" class="headerlink" title="PHP标记"></a>PHP标记</h3><p>&lt;?php 可以让代码进入“PHP 模式”<br>?&gt; 可以让代码退出“PHP 模式”</p><h3 id="省略结束标记"><a href="#省略结束标记" class="headerlink" title="省略结束标记"></a>省略结束标记</h3><p>​    如果 PHP 代码段处于整个文件的末尾，建议（必须）删除结束标记，这样不会有额外的空行产生</p><h3 id="输出内容方式"><a href="#输出内容方式" class="headerlink" title="输出内容方式"></a>输出内容方式</h3><p>echo：</p><p>print：</p><p>var_dump：</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​    你可以在代码中添加注释，从而增强我们代码的可阅读性。PHP 中注释有两种方式（与 JavaScript 相同）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 单行注释</span><br><span class="line">&lt;?php</span><br><span class="line">// 这是一条单行注释</span><br><span class="line"># 井号也可以做注释（不要用，有点生僻）</span><br><span class="line">$foo = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 多行注释</span><br><span class="line">&lt;?php</span><br><span class="line">/*</span><br><span class="line">......</span><br><span class="line">这里可以添加任意行数的注释内容</span><br><span class="line">......</span><br><span class="line">*/</span><br><span class="line">$foo = &apos;hello&apos;;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量 —— 用于临时存放数据的容器</span><br><span class="line">顺序结构 —— 先干什么再干什么</span><br><span class="line">分支结构 —— 如果怎样就怎样否则怎样</span><br><span class="line">循环结构 —— 不断的做某件相同的事</span><br><span class="line">函数 —— 提前设计好一件事怎么干，然后想什么时候干就什么时候干</span><br><span class="line">运算符 —— 数学运算和字符串拼接</span><br><span class="line">字面量 —— 在代码中用某些字符组成，能够表达一个具体的值 这些字符之间表示数据的方式叫做字面量</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    常见的 PHP 数据类型与 JavaScript 基本一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string（字符串）</span><br><span class="line">integer（整型）—— 只能存整数</span><br><span class="line">float（浮点型）—— 可以存带小数位的数字</span><br><span class="line">boolean（布尔型）</span><br><span class="line">array（数组）</span><br><span class="line">object（对象）</span><br><span class="line">NULL（空）</span><br><span class="line">Resource（资源类型）</span><br><span class="line">Callback / Callable（回调或者叫可调用类型）</span><br><span class="line"></span><br><span class="line">PHP 是一门弱类型语言，PHP会根据变量的值，自动把变量转换为正确的数据类型。</span><br><span class="line">在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​    变量是编程语言中临时存放数据的容器。</p><p>​    一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。变量名同样是区分大小写的。<br>    PHP 中变量无需声明类型，变量的类型根据值的类型来推断，PHP是弱类型的语言。</p><h3 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//PHP 有三种不同的变量作用域：</span><br><span class="line">local   局部</span><br><span class="line">global  全局</span><br><span class="line">static  静态</span><br></pre></td></tr></table></figure><h3 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h3><p>​    超全局变量是在全部作用域中始终可用的内置变量。PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。</p><p>​    这些超全局变量是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS — 引用全局作用域中可用的全部变量</span><br><span class="line">$_SERVER — 获取服务端相关信息</span><br><span class="line">$_REQUEST — 获取提交参数</span><br><span class="line">$_POST — 获取 POST 提交参数</span><br><span class="line">$_GET — 获取 GET 提交参数</span><br><span class="line">$_FILES — 获取上传文件</span><br><span class="line">$_ENV — 操作环境变量</span><br><span class="line">$_COOKIE — 操作 Cookie</span><br><span class="line">$_SESSION — 操作 Session</span><br></pre></td></tr></table></figure><h3 id="常量定义与使用"><a href="#常量定义与使用" class="headerlink" title="常量定义与使用"></a>常量定义与使用</h3><blockquote><p>常量跟变量一样也是一个数据容器，但是不同的是一旦申明过后就不允许被修改。</p></blockquote><h4 id="常量介绍"><a href="#常量介绍" class="headerlink" title="常量介绍"></a>常量介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常量就是恒定不变的量。</span><br><span class="line">常量的特点：</span><br><span class="line">1、常量前面没有美元符号($)</span><br><span class="line">2、常量可以不用理会变量的作用域在任何地方定义和访问</span><br><span class="line">3、常量一旦定义就不能重新定义或取消定义  unset()会报错</span><br><span class="line">4、常量的值只能是常量  &quot;a  &quot;abc&quot;  123</span><br></pre></td></tr></table></figure><h4 id="const和define区别："><a href="#const和define区别：" class="headerlink" title="const和define区别："></a>const和define区别：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、const可在类中使用，define不能</span><br><span class="line">2、define一般情况可以用来定义全局变量</span><br><span class="line">3、const不能再条件语句中定义常量，define可以</span><br><span class="line">4、define的值可以是任何表达式，const的值只可以是常量</span><br><span class="line">     define(&apos;BIT_5&apos;, 1 &lt;&lt; 5)</span><br></pre></td></tr></table></figure><h2 id="php面向对象"><a href="#php面向对象" class="headerlink" title="php面向对象"></a>php面向对象</h2><h3 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 面向对象的基本概念</span></span><br><span class="line">类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</span><br><span class="line"></span><br><span class="line">对象 − 是类的实例。</span><br><span class="line"></span><br><span class="line">成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</span><br><span class="line"></span><br><span class="line">成员函数 − 定义在类的内部，可用于访问对象的数据。</span><br><span class="line"></span><br><span class="line">继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</span><br><span class="line"></span><br><span class="line">父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</span><br><span class="line"></span><br><span class="line">子类 − 一个类继承其他类称为子类，也可称为派生类。</span><br><span class="line"></span><br><span class="line">多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</span><br><span class="line"></span><br><span class="line">抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</span><br><span class="line"></span><br><span class="line">封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</span><br><span class="line"></span><br><span class="line">构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与<span class="keyword">new</span>运算符一起使用在创建对象的语句中。</span><br><span class="line"></span><br><span class="line">析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做<span class="string">"清理善后"</span> 的工作（例如在建立对象时用<span class="keyword">new</span>开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</span><br></pre></td></tr></table></figure><h3 id="PHP重载"><a href="#PHP重载" class="headerlink" title="PHP重载"></a>PHP重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.php是弱类型语言，并没有像JAVA这种强类型语言一样有重载。</span><br><span class="line">2.在其他语言中，重载一般来说就是拥有相同的函数名或方法名，但是参数列表却不同(包括参数个数和参数类型)。</span><br><span class="line">3.在php中，重载一般用于对于当前对象的不可访问成员(私有的属性和方法)的处理。</span><br><span class="line">4.php通过魔术方法（magic methods __开头的方法）来实现重载，当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。</span><br><span class="line">5.魔法方法都是以public开头的</span><br><span class="line"></span><br><span class="line"># 魔法方法的介绍</span><br><span class="line">public function __set ($name,$value )</span><br><span class="line">public function __get ($name )</span><br><span class="line">public function __isset ($name )</span><br><span class="line">public function __unset ($name )</span><br><span class="line"></span><br><span class="line">在给不可访问的属性赋值时，__set() 会被调用。</span><br><span class="line">读取不可访问的属性的值时，__get()会被调用。</span><br><span class="line">当判断不可访问的属性是否存在的时候（使用isset()，empty()）时，__isset()会被调用。</span><br><span class="line">当对不可访问的属性执行销毁操作（unset()）的时候，__unset()会被调用。</span><br></pre></td></tr></table></figure><h3 id="命名空间介绍"><a href="#命名空间介绍" class="headerlink" title="命名空间介绍"></a>命名空间介绍</h3><p>​    命名空间将代码划分出不同的空间（区域），每个空间的常量、函数、类（为了偷懒，我下边都将它们称为元素）的名字互不影响， 这个有点类似java中的package。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//没有命名空间存在的问题：</span><br><span class="line">1.命名空间一个最明确的目的就是解决重名问题，PHP中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。这种情况下只要避免命名重复就可以解决，最常见的一种做法是约定一个前缀。</span><br><span class="line">2.比如：项目中有两个模块：article和message board，它们各自有一个处理用户留言的类Comment。这时候同时引入两个的Comment类显然是不行的，代码会出错。这时只能重构类名，我约定了一个命名规则，在类名前面加上模块名，像这样：Article_Comment、MessageBoard_Comment。但是这会导致命名过长的问题，解决方案就是使用命名空间。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2018/03/21/HTTP/"/>
      <url>/2018/03/21/HTTP/</url>
      
        <content type="html"><![CDATA[<h4 id="1-AJAX"><a href="#1-AJAX" class="headerlink" title="1.AJAX"></a>1.AJAX</h4><p>url：请求地址<br>type：请求方法，默认为 get<br>dataType：服务端响应数据类型</p><a id="more"></a><p>contentType：请求体内容类型，默认 application/x-www-form-urlencoded<br>data：需要传递到服务端的数据，如果 GET 则通过 URL 传递，如果 POST 则通过请求体传递<br>timeout：请求超时时间</p><p>beforeSend：请求发起之前触发<br>success：请求成功之后触发（响应状态码 200）<br>error：请求失败触发<br>complete：请求完成触发（不管成功与否）</p><h4 id="2-GET和POST的区别"><a href="#2-GET和POST的区别" class="headerlink" title="2.GET和POST的区别"></a>2.GET和POST的区别</h4><ul><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h4 id="3-Accept和Content-Type"><a href="#3-Accept和Content-Type" class="headerlink" title="3.Accept和Content-Type"></a>3.Accept和Content-Type</h4><p>Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。<br>服务器使用 Content-Type 应答头通知客户端它的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html</span><br><span class="line">Accept: image/*</span><br><span class="line">Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span><br></pre></td></tr></table></figure><p>1.Accept属于请求头， Content-Type属于实体头。 <br><br>Http报头分为通用报头，请求报头，响应报头和实体报头。 <br><br>请求方的http报头结构：通用报头|请求报头|实体报头 <br><br>响应方的http报头结构：通用报头|响应报头|实体报头<br></p><p>2.Accept代表发送端（客户端）希望接受的数据类型。 <br><br>比如：Accept：text/xml; <br><br>代表客户端希望接受的数据类型是xml类型<br></p><p>Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 <br><br>比如：Content-Type：text/html; <br><br>代表发送端发送的数据格式是html。<br></p><p>二者合起来， <br><br>Accept:text/xml； <br><br>Content-Type:text/html <br><br>即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。<br></p><h4 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4.状态码"></a>4.状态码</h4><table><thead><tr><th>状态码</th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>Informational（信息状态码）</td><td>接受请求正在处理</td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要附加操作已完成请求</td></tr><tr><td>4xx</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p>166、HTTP 状态消息 200 302 304 403 404 500 分别表示什么<br>200：请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>302：请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当<br>继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，<br>这个响应才是可缓存的<br>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上<br>次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁<br>止包含消息体，因此始终以消息头后的第一个空行结尾。<br>403：服务器已经理解请求，但是拒绝执行它。<br>404：请求失败，请求所希望得到的资源未被在服务器上发现。<br>500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这<br>个问题都会在服务器端的源代码出现错误时出现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型</title>
      <link href="/2018/02/16/JavaScript%E5%8E%9F%E5%9E%8B/"/>
      <url>/2018/02/16/JavaScript%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="原型介绍"><a href="#原型介绍" class="headerlink" title="原型介绍"></a>原型介绍</h2><p>​    什么是原型：原型是Javascript中的继承的基础，我们可以把一个函数的所有对象公共的属性和方法放入到函数的原型中。</p><a id="more"></a><h3 id="通过原型共享属性和方法"><a href="#通过原型共享属性和方法" class="headerlink" title="通过原型共享属性和方法"></a>通过原型共享属性和方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型来添加方法,解决数据共享,节省内存空间</span></span><br><span class="line">Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃凉菜"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.eat==p2.eat);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(p1);</span><br><span class="line"><span class="built_in">console</span>.dir(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么样子的数据是需要写在原型中?</span></span><br><span class="line"><span class="number">1.</span>需要共享的数据就可以写原型中，比如需要共享的属性和方法</span><br><span class="line"><span class="number">2.</span>不需要共享的数据写在构造函数中</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型的作用一:数据共享</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有学生的身高都是188,所有人的体重都是55</span></span><br><span class="line"><span class="comment">//所有学生都要每天写500行代码</span></span><br><span class="line"><span class="comment">//所有学生每天都要吃一个10斤的西瓜</span></span><br><span class="line"><span class="comment">//原型对象</span></span><br><span class="line">Student.prototype.height=<span class="string">"188"</span>;</span><br><span class="line">Student.prototype.weight=<span class="string">"55kg"</span>;</span><br><span class="line">Student.prototype.study=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"学习,写500行代码,小菜一碟"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Student.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"吃一个10斤的西瓜"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例化对象,并初始化</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"晨光"</span>,<span class="number">57</span>,<span class="string">"女"</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(Student);<span class="comment">//可以看到Student函数中有一个prototype，prototype中存放了我们所定义的若干方法</span></span><br><span class="line"><span class="built_in">console</span>.dir(stu);<span class="comment">//可以看到stu的__proto__实际就是Student.prototype</span></span><br></pre></td></tr></table></figure><h3 id="原型-prototype和-proto"><a href="#原型-prototype和-proto" class="headerlink" title="原型: prototype和 proto "></a>原型: prototype和<strong> proto </strong></h3><p>​    实例对象中有<strong> proto </strong>这个属性,指向函数的原型,是一个对象,这个属性是给浏览器使用,不是标准的属性<br>    构造函数中有prototype这个属性,叫函数的原型,是一个对象,这个属性是给程序员使用,是标准的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name=name;</span><br><span class="line">     <span class="keyword">this</span>.age=age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//通过原型来添加方法,解决数据共享,节省内存空间</span></span><br><span class="line">   Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"吃凉菜"</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line">   <span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.dir(p1);</span><br><span class="line">   <span class="built_in">console</span>.dir(p2);</span><br><span class="line">   <span class="built_in">console</span>.dir(Person);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(p1.__proto__==Person.prototype); <span class="comment">//true</span></span><br><span class="line">   p1.__proto__.eat();</span><br></pre></td></tr></table></figure><h3 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h3><p>​    1. 任何函数都具有一个    <code>prototype</code> 属性，该属性是一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2. 构造函数的 <code>prototype 对象默认都有一个</code>constructor<code>属性，指向</code>prototype对象所在函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.prototype.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>​    3. 通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__.constructor==F);</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__.constructor === F.prototype.constructor) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>​    4.总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 任何函数都具有一个 prototype 属性，该属性是一个对象</span><br><span class="line">2) 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数</span><br><span class="line">3) 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__</span><br><span class="line">4) 所有实例都直接或间接继承了原型对象的成员</span><br><span class="line">5) 构造函数的原型对象(prototype)中的属性和方法是可以被实例对象直接访问的</span><br></pre></td></tr></table></figure><h3 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h3><p>​    我们注意到，前面例子中每添加一个属性和方法就要敲一遍     <code>Person.prototype</code> 。<br>    为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Person~~~hi!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这样修改完之后，Person的原型中只有type和sayHello信息，把之前的sayHi以及constructor给丢失了*/</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  type: <span class="string">'human'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在该示例中，我们将   <code>Person.prototype</code> 重置到了一个新的对象。<br>    这样做的好处就是为   <code>Person.prototype</code> 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 <code>constructor</code> 成员(其实我们不写的时候会把constructor设置为Object的构造器)。</p><p>​    所以，我们为了保持   <code>constructor</code> 的指向正确，建议的写法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Person~~~hi!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // =&gt; 手动将 <span class="keyword">constructor</span> 指向正确的构造函数</span><br><span class="line">  type: 'human',</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Person~~~hi!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型方法的互相访问"><a href="#原型方法的互相访问" class="headerlink" title="原型方法的互相访问"></a>原型方法的互相访问</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型对象中的方法,可以相互调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型中添加方法</span></span><br><span class="line">Animal.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"动物吃东西"</span>);</span><br><span class="line">    <span class="keyword">this</span>.play();</span><br><span class="line">&#125;;</span><br><span class="line">Animal.prototype.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"玩球"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sleep();</span><br><span class="line">&#125;;</span><br><span class="line">Animal.prototype.sleep=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"睡觉了"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">"小苏"</span>,<span class="number">20</span>);</span><br><span class="line">dog.eat();</span><br></pre></td></tr></table></figure><h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>​    所有函数都有 prototype 属性对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Object.prototype</span><br><span class="line">2. Function.prototype</span><br><span class="line">3. Array.prototype</span><br><span class="line">4. String.prototype</span><br><span class="line">5. Number.prototype</span><br><span class="line">6. Date.prototype</span><br><span class="line">7. ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件</title>
      <link href="/2017/12/27/JavaScript%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/12/27/JavaScript%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="addEventListener和attachEvent区别"><a href="#addEventListener和attachEvent区别" class="headerlink" title="addEventListener和attachEvent区别"></a>addEventListener和attachEvent区别</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同点: 都可以为元素绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不同点:</span></span><br><span class="line">* <span class="number">1.</span>方法名不一样</span><br><span class="line">* <span class="number">2.</span>参数个数不一样addEventListener三个参数,attachEvent两个参数</span><br><span class="line">* <span class="number">3.</span>addEventListener 谷歌,火狐,IE11支持,IE8不支持</span><br><span class="line">*   attachEvent 谷歌火狐不支持,IE11不支持,IE8支持</span><br><span class="line">* <span class="number">4.</span><span class="keyword">this</span>不同,addEventListener 中的<span class="keyword">this</span>是当前绑定事件的对象</span><br><span class="line">*   attachEvent中的<span class="keyword">this</span>是<span class="built_in">window</span>。(IE8中其实通过apply、call改变了<span class="keyword">this</span>的指向)</span><br><span class="line">* <span class="number">5.</span>addEventListener中事件的类型(事件的名字)没有on</span><br><span class="line">*   attachEvent中的事件的类型(事件的名字)有on</span><br></pre></td></tr></table></figure><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。 每一个事件的生成都有一个event对象，这个对象中包含该事件的类型、触发者、触发位置等信息</p><ul><li>event.type 获取事件类型</li><li>event.target || event.srcElement 用于获取触发事件的元素</li><li>clientX/clientY     所有浏览器都支持，可视区位置</li><li>pageX/pageY       IE8以前不支持，页面位置</li><li>event.preventDefault() 取消默认行为</li><li>event.stopPropagation() 阻止事件传播</li><li>获取键盘按键信息</li></ul><h4 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h4><ul><li>事件源 : 触发(被)事件的元素</li><li>事件类型 : 事件的触发方式(例如鼠标点击或键盘点击)</li><li>事件处理程序 : 事件触发后要执行的代码(函数形式)</li></ul><h4 id="event对象的获取"><a href="#event对象的获取" class="headerlink" title="event对象的获取"></a>event对象的获取</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件参数e在IE8的浏览器中是不存在,此时用window.event来代替</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//兼容性写法：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="event-type的使用"><a href="#event-type的使用" class="headerlink" title="event.type的使用"></a>event.type的使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"呵呵"</span> id=<span class="string">"btn"</span>/&gt;</span><br><span class="line"></span><br><span class="line">my$(<span class="string">"btn"</span>).onclick = f1;</span><br><span class="line">my$(<span class="string">"btn"</span>).onmouseover = f1;</span><br><span class="line">my$(<span class="string">"btn"</span>).onmouseout = f1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">alert(<span class="string">"好帅哦"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line"><span class="keyword">this</span>.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line"><span class="keyword">this</span>.style.backgroundColor = <span class="string">"green"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻止事件传播的方式"><a href="#阻止事件传播的方式" class="headerlink" title="阻止事件传播的方式"></a>阻止事件传播的方式</h4><p>​        事件传递 : 多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发了,外面的元素的该事件自动的触发了。</p><h5 id="为什么有事件传播："><a href="#为什么有事件传播：" class="headerlink" title="为什么有事件传播："></a>为什么有事件传播：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//事件可以分为三个阶段</span><br><span class="line">* 1.事件捕获阶段  : 从外向内</span><br><span class="line">* 2.事件目标阶段  : 最开始选择的那个</span><br><span class="line">* 3.事件冒泡阶段  : 从里向外</span><br><span class="line"></span><br><span class="line">//为元素绑定事件</span><br><span class="line">* addEventListener(&quot;没有on的事件类型&quot;,事件处理函数,控制事件阶段的)</span><br><span class="line"></span><br><span class="line">//addEventListener中第三个参数是控制事件阶段的</span><br><span class="line">* 通过e.eventPhase这个属性可以知道当前的事件是什么阶段</span><br><span class="line"></span><br><span class="line">//如果e.eventPhase这个属性的值是:</span><br><span class="line">* 1----&gt;捕获阶段</span><br><span class="line">* 2----&gt;目标阶段</span><br><span class="line">* 3----&gt;冒泡</span><br><span class="line"></span><br><span class="line">//一般默认都是冒泡阶段,很少用捕获阶段</span><br><span class="line">* 捕获阶段:从外向内</span><br><span class="line">* 冒泡阶段:从里向外</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"dv1"</span>&gt;</span><br><span class="line">  &lt;div id=<span class="string">"dv2"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"dv3"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//事件冒泡:是从里向外</span></span><br><span class="line">  <span class="comment">//同时注册点击事件</span></span><br><span class="line">  <span class="keyword">var</span> objs = [my$(<span class="string">"dv3"</span>), my$(<span class="string">"dv2"</span>), my$(<span class="string">"dv1"</span>)];</span><br><span class="line">  <span class="comment">//遍历注册事件</span></span><br><span class="line">  objs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//为每个元素绑定事件</span></span><br><span class="line">    ele.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.id+<span class="string">"====&gt;"</span>+e.eventPhase);</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在addEventListener函数最后一个参数是true或者false情况下，我们可以看到打印结果的变化</span></span><br></pre></td></tr></table></figure><h5 id="如何阻止事件传播"><a href="#如何阻止事件传播" class="headerlink" title="如何阻止事件传播"></a>如何阻止事件传播</h5><ul><li>标准方式 event.stopPropagation();  谷歌和火狐支持</li><li>event.cancelBubble = true; 标准中已废弃   IE特有的,谷歌支持,火狐不支持</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"fun1"</span>);</span><br><span class="line"><span class="comment">//w3c标准</span></span><br><span class="line"><span class="keyword">if</span>(e&amp;&amp;e.stopPropagation)&#123;</span><br><span class="line">e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ie</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h4><p>非IE    e.preventDefault()</p><p>IE        event.returnValue = true;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.baidu.com"</span> onclick=<span class="string">"fn(event)"</span>&gt;点击我吧&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">function fn(e)&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/查看e是否存在preventDefault方法</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/火狐浏览器(w3c标准)</span></span><br><span class="line"><span class="regexp">if(e&amp;&amp;e.preventDefault)&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/阻止默认行为</span></span><br><span class="line"><span class="regexp">e.preventDefault();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ie浏览器(后期版本的ie也遵从了w3c规范)</span></span><br><span class="line"><span class="regexp">else&#123;</span></span><br><span class="line"><span class="regexp">window.event.returnValue = true;</span></span><br><span class="line"><span class="regexp">         return false;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h4><h5 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h5><p>​    代理是一种常用的设计模式，代理模式可以对原有的类进行扩展，即通过代理对象的模式来访问目标类。最通俗的例子就是假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的。明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子。</p><p>​    代理的好处：</p><p>​    1.限制对象的访问权限</p><p>​    2.在不改变目标对象代码的基础上为它动态的添加功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.talkBusiness = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"谈了1个亿的生意"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Agent</span>(<span class="params">name,p</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.p = p;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.talkBusiness = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//目标对象的目标方法之前做的事情</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"谈生意之前制定计划"</span>);</span><br><span class="line"> <span class="comment">//目标对象调用目标方法</span></span><br><span class="line"> <span class="keyword">this</span>.p.talkBusiness();</span><br><span class="line"> <span class="comment">//目标对象的目标方法之后做的事情</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"谈生意之后做总结"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//目标对象</span></span><br><span class="line"> <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"成龙"</span>);</span><br><span class="line"> <span class="comment">//代理对象</span></span><br><span class="line"> <span class="keyword">var</span> a = <span class="keyword">new</span> Agent(<span class="string">"华谊传媒"</span>,p);</span><br><span class="line"> a.talkBusiness();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的组成</title>
      <link href="/2017/12/18/JavaScript%E7%9A%84%E7%BB%84%E6%88%90/"/>
      <url>/2017/12/18/JavaScript%E7%9A%84%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><p>JavaScript=ECMAScript+DOM+BOM</p><a id="more"></a><h4 id="ECMAScript-JavaScript的核心"><a href="#ECMAScript-JavaScript的核心" class="headerlink" title="ECMAScript - JavaScript的核心"></a>ECMAScript - JavaScript的核心</h4><p>​    定义了javascript的语法规范</p><p>​    JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p><h4 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM - 浏览器对象模型"></a>BOM - 浏览器对象模型</h4><p>​    一套操作浏览器功能的API</p><p>​    通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p><h4 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM - 文档对象模型"></a>DOM - 文档对象模型</h4><p>​    一套操作页面元素的API</p><p>​    DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM的概念"><a href="#DOM的概念" class="headerlink" title="DOM的概念"></a>DOM的概念</h3><p>​    文档对象模型（Document Object Model，简称DOM），是<a href="http://baike.baidu.com/item/W3C" target="_blank" rel="noopener">W3C</a>组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。</p><p>​    Document Object Model的历史可以追溯至1990年代后期微软与<a href="http://baike.baidu.com/item/Netscape" target="_blank" rel="noopener">Netscape</a>的“浏览器大战”，双方为了在<a href="http://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a>与<a href="http://baike.baidu.com/item/JScript" target="_blank" rel="noopener">JScript</a>一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有<a href="http://baike.baidu.com/item/VBScript" target="_blank" rel="noopener">VBScript</a>、<a href="http://baike.baidu.com/item/ActiveX" target="_blank" rel="noopener">ActiveX</a>、以及微软自家的<a href="http://baike.baidu.com/item/DHTML" target="_blank" rel="noopener">DHTML</a>格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。</p><p>​    DOM又称为文档树模型</p><ul><li><p>文档：一个网页可以称为文档</p></li><li><p>节点：网页中的所有内容都是节点（标签、属性、文本、注释等）</p></li><li><p>元素：网页中的标签</p></li><li><p>属性：标签的属性</p><h3 id="DOM可以做什么"><a href="#DOM可以做什么" class="headerlink" title="DOM可以做什么"></a>DOM可以做什么</h3><ul><li>获取元素</li><li>动态创建元素</li><li>对元素进行操作(设置其属性或调用其方法)</li><li>事件(什么时机做相应的操作)</li></ul><h3 id="添加事件的三种方式"><a href="#添加事件的三种方式" class="headerlink" title="添加事件的三种方式"></a>添加事件的三种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1.初级方案</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; onclick=&quot;alert(&apos;我被点了&apos;)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">//2.中级方案</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function f1() &#123;</span><br><span class="line">    alert(&quot;这是一个对话框&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; onclick=&quot;f1()&quot;/&gt;</span><br><span class="line"></span><br><span class="line">//3.最终方案：使用dom对象进行事件分配</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;开始分离代码&quot; id=&quot;btn1&quot; /&gt;</span><br><span class="line">//  //根据id属性的值从整个文档中获取这个元素(标签)</span><br><span class="line">var btnObj1=document.getElementById(&quot;btn1&quot;);</span><br><span class="line">  //为该元素注册点击事件</span><br><span class="line">btnObj1.onclick=function () &#123;</span><br><span class="line">    alert(&quot;哦,这真是太好了&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//根据id属性的值从整个文档中获取这个元素(标签)</span><br><span class="line">//为该元素注册点击事件</span><br><span class="line">document.getElementById(&quot;btn1&quot;).onclick=function () &#123;</span><br><span class="line">  alert(&quot;哦,这真是太好了&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//注意  : &lt;script&gt;标签在body前后位置带来的影响</span><br></pre></td></tr></table></figure><h2 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h2><h3 id="根据id获取元素"><a href="#根据id获取元素" class="headerlink" title="根据id获取元素"></a>根据id获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到的数据类型 HTMLDivElement，对象都是有类型的</span></span><br><span class="line"><span class="comment">// HTMLDivElement &lt;-- HTMLElement &lt;-- Element  &lt;-- Node  &lt;-- EventTarget</span></span><br></pre></td></tr></table></figure><p>​    注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。</p><h3 id="根据标签名获取元素"><a href="#根据标签名获取元素" class="headerlink" title="根据标签名获取元素"></a>根据标签名获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = divs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据name获取元素"><a href="#根据name获取元素" class="headerlink" title="根据name获取元素"></a>根据name获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputs = <span class="built_in">document</span>.getElementsByName(<span class="string">'hobby'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; inputs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> input = inputs[i];</span><br><span class="line">  <span class="built_in">console</span>.log(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据类名获取元素"><a href="#根据类名获取元素" class="headerlink" title="根据类名获取元素"></a>根据类名获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h5，IE9之后支持</span></span><br><span class="line"><span class="keyword">var</span> mains = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mains.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> main = mains[i];</span><br><span class="line">  <span class="built_in">console</span>.log(main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据选择器获取元素"><a href="#根据选择器获取元素" class="headerlink" title="根据选择器获取元素"></a>根据选择器获取元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">'#text'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boxes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.box'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; boxes.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> box = boxes[i];</span><br><span class="line">  <span class="built_in">console</span>.log(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getElementsByTagName和querySelector的区别"><a href="#getElementsByTagName和querySelector的区别" class="headerlink" title="getElementsByTagName和querySelector的区别"></a>getElementsByTagName和querySelector的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.区别</span></span><br><span class="line">getElementsByTagName获取的是动态集合，querySelector获取的是静态集合。</span><br><span class="line">简单的说就是，动态就是选出的元素会随文档改变，静态的不会，取出来之后就和文档的改变无关了。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.应用场景</span></span><br><span class="line">如果只要一次查找就可得到元素时，首选querySelector ；</span><br><span class="line">如果需要经过多级查找，才能得到元素时，用getElementsByTagName；</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;aaa&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;ddd&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;ccc&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>];</span><br><span class="line">    lis = ul.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log( lis.length);  <span class="comment">//4</span></span><br><span class="line">&lt;<span class="regexp">/script&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    var ul = document.getElementsByTagName('ul')[0];</span></span><br><span class="line"><span class="string">    var lis = document.querySelectorAll('li');</span></span><br><span class="line"><span class="string">    ul.appendChild(document.createElement("</span>li<span class="string">"));</span></span><br><span class="line"><span class="string">    console.log( lis.length);  //3</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id属性的值获取元素,返回来的是一个元素对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementById(<span class="string">"id属性的值"</span>);</span><br><span class="line"><span class="comment">//根据标签名字获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementsByTagName(<span class="string">"标签名字"</span>);</span><br><span class="line"><span class="comment">//下面的几个,有的浏览器不支持</span></span><br><span class="line"><span class="comment">//根据name属性的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementsByName(<span class="string">"name属性的值"</span>)</span><br><span class="line"><span class="comment">//根据类样式的名字来获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.getElementsByClassName(<span class="string">"类样式的名字"</span>)</span><br><span class="line"><span class="comment">//根据选择器获取元素,返回来的是一个元素对象</span></span><br><span class="line">* <span class="built_in">document</span>.querySelector(<span class="string">"选择器的名字"</span>);</span><br><span class="line"><span class="comment">//根据选择器获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象</span></span><br><span class="line">* <span class="built_in">document</span>.querySelectorAll(<span class="string">"选择器的名字"</span>)</span><br></pre></td></tr></table></figure><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><h3 id="非表单元素的属性"><a href="#非表单元素的属性" class="headerlink" title="非表单元素的属性"></a>非表单元素的属性</h3><ul><li>href、title、id、src</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.baidu.com"</span> title=<span class="string">"baidu"</span> id=<span class="string">"link"</span>&gt;点我&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var link = document.getElementById('link');</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/通过console.dir(link) 可以查看该a节点对象的所有信息</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/通过打印我们发现除了title和href属性之外，document文档对象模型还帮我们封装了其他很多属性</span></span><br><span class="line"><span class="regexp">console.dir(link);</span></span><br><span class="line"><span class="regexp">console.log(link.href);</span></span><br><span class="line"><span class="regexp">console.log(link.title);</span></span><br><span class="line"><span class="regexp">console.log(link.host);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var pic = document.getElementById('pic');</span></span><br><span class="line"><span class="regexp">console.log(pic.src);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/我们也可以直接通过link.href = "xx"来给属性赋值</span></span><br></pre></td></tr></table></figure><ul><li>innerText/textContent/innerHTML/value</li></ul><p>​       a) textContent和innerText的区别</p><p>​          textContent : 设置标签中的文本内容,谷歌,火狐支持,IE8不支持</p><pre><code>innerText : 设置标签中的文本内容,谷歌,火狐,IE8都支持</code></pre><p>​           如果这个属性在浏览器中不支持,那么这个属性的类型是undefined，所以判断这个属性的类型是不是    undefined,就知道浏览器是否支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置任意的标签中间的任意文本内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element,text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断浏览器是否支持这个属性</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> element.textContent ==<span class="string">"undefined"</span>)&#123;</span><br><span class="line">      <span class="comment">//不支持</span></span><br><span class="line">      element.innerText=text;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//支持这个属性</span></span><br><span class="line">      element.textContent=text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取任意标签中间的文本内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> element.textContent==<span class="string">"undefined"</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> element.innerText;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> element.textContent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    b) innerText和innerHTML的区别</p><p>​           如果使用innerText主要是设置和获取文本的,设置标签内容,是没有标签的效果的</p><pre><code>innerHTML主要的作用是在标签中设置新的html或者获取html标签内容,是有标签效果的</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my$(<span class="string">"btn"</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   my$(<span class="string">"dv"</span>).innerText=<span class="string">"哈哈"</span>;<span class="comment">//设置文本</span></span><br><span class="line">   my$(<span class="string">"dv"</span>).innerText=<span class="string">"&lt;p&gt;这是一个p&lt;/p&gt;"</span>;<span class="comment">//设置html标签的代码</span></span><br><span class="line"></span><br><span class="line">   my$(<span class="string">"dv"</span>).innerHTML=<span class="string">"哈哈"</span>;</span><br><span class="line">   my$(<span class="string">"dv"</span>).innerHTML=<span class="string">"&lt;p&gt;这是一个p&lt;/p&gt;"</span>;<span class="comment">//设置Html标签的</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取</span></span><br><span class="line"> my$(<span class="string">"btn2"</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//可以获取标签中的文本内容</span></span><br><span class="line">   <span class="built_in">console</span>.log(my$(<span class="string">"dv"</span>).innerText);</span><br><span class="line">   <span class="built_in">console</span>.log(my$(<span class="string">"dv"</span>).innerHTML);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>​    c)  value : 主要是用来给value属性赋值</p><ul><li>类名操作 : 修改标签的className属性相当于直接修改标签的类名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.className = <span class="string">'clearfix'</span>;</span><br></pre></td></tr></table></figure><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、获取行内（内嵌、行间）样式：</span></span><br><span class="line">    obj.style.attr;进行获取非行间样式。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、设置行内样式：</span></span><br><span class="line">    obj.style.attr = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、举例：</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line">box.style.width = <span class="string">'100px'</span>;</span><br><span class="line">box.style.height = <span class="string">'100px'</span>;</span><br><span class="line">box.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line"><span class="comment">//通过样式属性设置宽高、位置的属性类型是字符串，需要加上px</span></span><br></pre></td></tr></table></figure></li></ul><p>节点介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">节点(Node)的分类：</span><br><span class="line">文档节点  Document</span><br><span class="line">元素节点  Element  指的是页面中的标签</span><br><span class="line">属性节点  Attr</span><br><span class="line">文本节点  Text</span><br><span class="line"></span><br><span class="line">节点的属性：</span><br><span class="line">nodeType ： 1--&gt;标签，2--&gt;属性,3--&gt;文本</span><br><span class="line">nodeName ： 标签--&gt;标签名，属性--&gt;属性名，文本--&gt;#text</span><br><span class="line">nodeValue : 标签--&gt;null，属性--&gt;属性值，文本--&gt;文本内容</span><br><span class="line"></span><br><span class="line">节点层次的属性</span><br><span class="line">parentNode    ---父节点</span><br><span class="line">    parentElement  ---父元素(结果和parentNode一样)</span><br><span class="line">childNodes    ---所有子节点，包含文本节点</span><br><span class="line">children      -- 所有子元素</span><br><span class="line">nextSibling/previousSibling   --前一个子节点(包含文本节点),IE8中获取第一个子元素</span><br><span class="line">    nextElementSibling/previousElementSibling   --前一个子元素，IE8中不支持</span><br><span class="line">firstChild/lastChild   --获取第一个子节点，IE8中是第一个子元素</span><br><span class="line">    firstElementChild      --获取第一个子元素，IE8中不支持</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-对象</title>
      <link href="/2017/10/13/JavaScript-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/10/13/JavaScript-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>面向过程：关注的是问题解决的步骤，注重过程<br>面向对象：关注的是问题解决的主体，注重结果    </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。</span><br><span class="line">举例： 一部车，一个手机</span><br><span class="line">车是一类事物，门口停的那辆车才是对象</span><br><span class="line">特征：红色、四个轮子</span><br><span class="line">行为：驾驶、刹车</span><br></pre></td></tr></table></figure><h3 id="JavaScript中的对象"><a href="#JavaScript中的对象" class="headerlink" title="JavaScript中的对象"></a>JavaScript中的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript中的对象其实就是生活中对象的一个抽象</span><br><span class="line">JavaScript的对象是无序属性的集合。</span><br><span class="line">其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。</span><br><span class="line">对象的行为和特征</span><br><span class="line">特征---属性</span><br><span class="line">行为---方法</span><br></pre></td></tr></table></figure><ul><li>事物的特征在对象中用属性来表示。</li><li>事物的行为在对象中用方法来表示。</li></ul><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>对象字面量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="literal">true</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//其实这种方法内部会自动调用new Object()方法来创建对象</span></span><br></pre></td></tr></table></figure><ul><li>new Object()创建对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'lisi'</span>;</span><br><span class="line">person.age = <span class="number">35</span>;</span><br><span class="line">person.job = <span class="string">'actor'</span>;</span><br><span class="line">person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,everyBody'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：每创建一个对象都要写一堆代码，太麻烦</span></span><br></pre></td></tr></table></figure><ul><li>工厂函数创建对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  person.name = name;</span><br><span class="line">  person.age = age;</span><br><span class="line">  person.job = job;</span><br><span class="line">  person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,everyBody'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'张三'</span>, <span class="number">22</span>, <span class="string">'actor'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：无法判断所创建出来的对象的具体类型  instanceof</span></span><br></pre></td></tr></table></figure><ul><li>自定义构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello,everyBody'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>, <span class="number">22</span>, <span class="string">'actor'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好处：既封装了内部实现，又能通过instanceof来判断所创建出来对象的具体类型</span></span><br></pre></td></tr></table></figure><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征</span><br><span class="line">如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能</span><br></pre></td></tr></table></figure><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><blockquote><p>构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p></blockquote><ol><li>构造函数用于创建一类对象，首字母要大写。</li><li>构造函数要和new一起使用才有意义。</li></ol><p>new在执行时会做四件事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 会在内存中创建一个新的空对象</span><br><span class="line">new 会让this指向这个新的对象</span><br><span class="line">执行构造函数  目的：给这个新对象加属性和方法</span><br><span class="line">new会返回这个新对象</span><br></pre></td></tr></table></figure><h3 id="设置和获取属性的另一种写法"><a href="#设置和获取属性的另一种写法" class="headerlink" title="设置和获取属性的另一种写法"></a>设置和获取属性的另一种写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"喜欢玩游戏"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">"卡卡西"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//obj.name="佐助";</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">"name"</span>]=<span class="string">"佐助"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line">obj.play();</span><br><span class="line">obj[<span class="string">"play"</span>]();</span><br></pre></td></tr></table></figure><h3 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h3><blockquote><p>通过for..in语法可以遍历一个对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  obj[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="comment">//因为此时遍历到的key是一个字符串，需要通过obj[key]的方式才能访问内容</span></span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">"=="</span> + obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'mm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fun(); </span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// mm </span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="简单类型和复杂类型的区别"><a href="#简单类型和复杂类型的区别" class="headerlink" title="简单类型和复杂类型的区别"></a>简单类型和复杂类型的区别</h3><p>浅谈js内存：<a href="https://www.jianshu.com/p/396c110378db" target="_blank" rel="noopener">https://www.jianshu.com/p/396c110378db</a></p><blockquote><p>基本类型又叫做值类型，复杂类型又叫做引用类型</p><p>值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。</p><p>引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。</p></blockquote><ul><li><p>堆和栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆栈空间分配区别：</span><br><span class="line">　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</span><br><span class="line">　　2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-预解析</title>
      <link href="/2017/09/30/JavaScript-%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/09/30/JavaScript-%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><blockquote><p>JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程</p><a id="more"></a></blockquote><p>预解析过程：</p><ol><li>把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。</li><li>把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</li><li>函数声明和变量声明都会置顶，但是变量声明位于函数声明之后</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 1、变量的提升</span><br><span class="line"></span><br><span class="line">var num = 10;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line">function fun() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(num);</span><br><span class="line"></span><br><span class="line">  var num = 20;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、函数的提升</span><br><span class="line"></span><br><span class="line">var a = 18;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">function f1() &#123;</span><br><span class="line"></span><br><span class="line">  var b = 9;</span><br><span class="line"></span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line">  console.log(b);</span><br><span class="line"></span><br><span class="line">  var a = &apos;123&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//隐式全局变量的注意点</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line">console.log(c);</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line"></span><br><span class="line">  var a = b = c = 9;</span><br><span class="line"></span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line">  console.log(b);</span><br><span class="line"></span><br><span class="line">  console.log(c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等效于</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line"></span><br><span class="line">  var a;  //局部变量</span><br><span class="line"></span><br><span class="line">  a = 9;  </span><br><span class="line"></span><br><span class="line">  b = 9;  //隐式全局变量</span><br><span class="line"></span><br><span class="line">  c = 9;  //隐式全局变量</span><br><span class="line"></span><br><span class="line">  console.log(a);  //9</span><br><span class="line"></span><br><span class="line">  console.log(b);  //9</span><br><span class="line"></span><br><span class="line">  console.log(c);  //9</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line">console.log(c);  //9</span><br><span class="line"></span><br><span class="line">console.log(b);  //9</span><br><span class="line"></span><br><span class="line">console.log(a);  //undefined   因为a是局部变量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//隐式全局变量的进一步说明</span><br><span class="line">var a = 18;</span><br><span class="line">b = 10;</span><br><span class="line">console.log(b);</span><br><span class="line"></span><br><span class="line">delete b;</span><br><span class="line">console.log(b);   //此处会报错，原因隐式全局变量的声明是可以通过delete关键字删除的。删除之后就没有b的定义，无法console.log()</span><br><span class="line"></span><br><span class="line">delete a; //全局变量是不可以delete的，此处delete无效</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">//函数提升在前，变量提升在后</span><br><span class="line">var a = 3;</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(10);</span><br><span class="line">&#125;   </span><br><span class="line">console.log(a);</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">//提升的时候，变量声明位于函数之后</span><br><span class="line">等效于：</span><br><span class="line">function a()&#123;</span><br><span class="line">    console.log(10)</span><br><span class="line">&#125;         //前</span><br><span class="line">var a;    //后</span><br><span class="line">a = 3;</span><br><span class="line">console.log(a);  //3</span><br><span class="line">a();  //not function</span><br><span class="line"></span><br><span class="line">//函数中出现和全局变量同名的变量  以及if中出现和全局变量同名的变量的处理方式</span><br><span class="line">var tmp = new Date();</span><br><span class="line">function f()&#123;</span><br><span class="line">    console.log(tmp);</span><br><span class="line">    if(false)&#123;</span><br><span class="line">        var tmp = &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">等效为：</span><br><span class="line">var tmp = new Date();</span><br><span class="line">function f()&#123;</span><br><span class="line">    var tmp;</span><br><span class="line">    console.log(tmp);</span><br><span class="line">    if(false)&#123;</span><br><span class="line">        tmp = &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为变量申明是在任意代码执行前处理的，在代码区中任意地方申明变量和在最开始（最上面）的地方申明是一样的。也就是说，看起来一个变量可以在申明之前被使用！这种行为就是所谓的“hoisting”，也就是变量提升，看起来就像变量的申明被自动移动到了函数或全局代码的最顶上。</span><br><span class="line"></span><br><span class="line">注意：仅仅是申明提升了，定义并不会被提升。</span><br><span class="line"></span><br><span class="line">//函数中出现和全局变量同名的变量  以及if中出现和全局变量同名的变量的处理方式</span><br><span class="line">var x = 1;</span><br><span class="line">console.log(x);</span><br><span class="line">if(true)&#123;</span><br><span class="line">    var x = 2;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);</span><br><span class="line"></span><br><span class="line">等效为</span><br><span class="line">var x = 1;</span><br><span class="line">console.log(x);</span><br><span class="line">if(true)&#123;</span><br><span class="line">    x = 2;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js的var变量只有全局作用域和函数作用域两种，且申明会被提升，因此实际上x只会在最顶上开始的地方申明一次，var x=2的申明会被忽略，仅用于赋值。也就是说上面的代码实际上跟下面是一致的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//匿名函数不存在预解析的问题</span><br><span class="line">f1();//-----报错</span><br><span class="line">var f1=function () &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a=10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的内存管理</title>
      <link href="/2017/09/29/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/09/29/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JS的内存管理"><a href="#JS的内存管理" class="headerlink" title="JS的内存管理"></a>JS的内存管理</h2><h3 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h3><p>​    JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。</p><a id="more"></a><p>　　垃圾收集机制原理：垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）， 周期性地执行这一操作：找出那些不再继续使用的变量，然后释放其占用的内存。</p><p>​    JS中大部分浏览器采用标记清除的垃圾回收机制，部分低版本的IE采用引用计数来实现垃圾的回收。</p><h3 id="JS垃圾回收机制-引用计数"><a href="#JS垃圾回收机制-引用计数" class="headerlink" title="JS垃圾回收机制-引用计数"></a>JS垃圾回收机制-引用计数</h3><h4 id="引用计数介绍"><a href="#引用计数介绍" class="headerlink" title="引用计数介绍"></a>引用计数介绍</h4><p>​    这种方式常常会引起内存泄漏，<strong>低版本的IE使用这种方式</strong>。</p><p>​    原理：当JavaScript代码生成一个新的内存驻留项时（比如一个对象或函数），系统就会为这个项留出一块内存空间。因为这个对象可能会被传递给很多函数，并且会被指定给很多变量，所以很多代码都会指向这个对象的内存空间。JavaScript会跟踪这些指针，当最后一个指针废弃不用时，这个对象占用的内存会被释放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ---------&gt; B ---------&gt; C</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如对象A有一个属性指向B，而B也有一个属性指向C。即使当前作用域中只有对象A有效，但由于指针的关系所有3个对象都必须保留在内存中。当离开A的当前作用域时（例如代码执行到声明A的函数的末尾处），垃圾收集器就可以释放A占用的内存。此时，由于没有什么指向B，因此B可以释放，最后，C也可以释放。</span></span><br></pre></td></tr></table></figure><h4 id="引用计数的问题-内存泄漏"><a href="#引用计数的问题-内存泄漏" class="headerlink" title="引用计数的问题-内存泄漏"></a>引用计数的问题-内存泄漏</h4><p>​    内存泄漏是指程序中己动态分配的堆<em>内存</em>由于某种原因程序未释放或无法释放，造成系统<em>内存</em>的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环引用导致内存泄漏 </span></span><br><span class="line">A ---------&gt; B ------------&gt; C</span><br><span class="line">             ^、_ _ _ _ _ _ _|</span><br><span class="line">                  </span><br><span class="line"><span class="comment">//这里，我们又为对象C添加了一个引用B的属性。在这种情况下，当A释放时，仍然有来自C的指针指向B。这种引用循环需要由JavaScript进行特殊的处理，但必须考虑到整个循环与作用域中的其他变量已经处于隔离状态。</span></span><br></pre></td></tr></table></figure><h4 id="什么时候会产生循环引用"><a href="#什么时候会产生循环引用" class="headerlink" title="什么时候会产生循环引用"></a>什么时候会产生循环引用</h4><h5 id="1-闭包的循环引用"><a href="#1-闭包的循环引用" class="headerlink" title="1.闭包的循环引用"></a>1.闭包的循环引用</h5><blockquote><p>​    闭包可能会导致在不经意间创建循环引用。因为函数是必须保存在内存中的对象，所以位于函数执行上下文中的所有变量也需要保存在内存中：</p></blockquote><h5 id="2-DOM与JavaScript的循环引用"><a href="#2-DOM与JavaScript的循环引用" class="headerlink" title="2.DOM与JavaScript的循环引用"></a>2.DOM与JavaScript的循环引用</h5><h3 id="JS垃圾回收机制-标记清除"><a href="#JS垃圾回收机制-标记清除" class="headerlink" title="JS垃圾回收机制-标记清除"></a>JS垃圾回收机制-标记清除</h3><h4 id="标记清除介绍"><a href="#标记清除介绍" class="headerlink" title="标记清除介绍"></a>标记清除介绍</h4><p>​    大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记清除算法由以下步骤组成：</span></span><br><span class="line"><span class="number">1.</span>垃圾回收器构建<span class="string">"roots"</span>列表。Roots通常是代码中保留引用的全局变量。在JavaScript中，<span class="string">"window"</span>对象可以作为 root 全局变量示例。</span><br><span class="line"><span class="number">2.</span>所有的<span class="string">"roots"</span>被检查并标记为active（即不是垃圾）。所有的children也被递归检查。从<span class="string">"root"</span>能够到达的一切都不被认为是垃圾。</span><br><span class="line"><span class="number">3.</span>所有为不被标记为active的内存可以被认为是垃圾了。收集器限制可以释放这些内存并将其返回到操作系统。</span><br></pre></td></tr></table></figure><p><img src="/2017/09/29/JavaScript的内存管理/" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-作用域</title>
      <link href="/2017/09/18/JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2017/09/18/JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域：变量可以起作用的范围</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><a id="more"></a><ul><li><p>全局变量</p><p>在任何地方都可以访问到的变量就是全局变量，对应全局作用域。在函数外声明。</p></li><li><p>局部变量</p><p>只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用var声明的变量是隐式全局变量，不推荐使用。</span><br><span class="line">变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁</span><br></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。<br><strong>在es5之前没有块级作用域的的概念,只有函数作用域</strong>，现阶段可以认为JavaScript没有块级作用域</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>因为 JavaScript 采用的是<strong>词法作用域，函数的作用域在函数定义的时候就决定了。</strong></p><p>而与词法作用域相对的是<strong>动态作用域，函数的作用域是在函数调用的时候才决定的。</strong></p><p><strong>在 js 中词法作用域规则:</strong></p><ul><li>函数允许访问函数外的数据.</li><li>整个代码结构中只有函数可以限定作用域.</li><li>作用域规则首先使用提升规则分析：声明会被提升，赋值不会提升</li><li>如果当前作用规则中有名字了, 就不考虑外面的名字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设JavaScript采用静态作用域，让我们分析下执行过程：</span><br><span class="line"></span><br><span class="line">执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 <span class="number">1</span>，所以结果会打印 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">假设JavaScript采用动态作用域，让我们分析下执行过程：</span><br><span class="line"></span><br><span class="line">执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>只有函数可以制造作用域结构。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</p><p>作用域链:变量的使用,从里向外,层层的搜索,搜索到了就可以直接使用了。层层搜索,搜索到0级作用域的时候,如果还是没有找到这个变量,结果就是报错</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的call,apply,bind</title>
      <link href="/2017/09/13/JavaScript%E4%B8%AD%E7%9A%84call-apply-bind/"/>
      <url>/2017/09/13/JavaScript%E4%B8%AD%E7%9A%84call-apply-bind/</url>
      
        <content type="html"><![CDATA[<h3 id="call、apply、bind：作用可以改变函数this的指向"><a href="#call、apply、bind：作用可以改变函数this的指向" class="headerlink" title="call、apply、bind：作用可以改变函数this的指向"></a>call、apply、bind：作用可以改变函数this的指向</h3><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和分别地提供的参数(参数的列表)。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：fun.call(thisArg,args...)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>(a+b);</span><br><span class="line">    <span class="built_in">console</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1.call(<span class="literal">null</span>,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参数：</span></span><br><span class="line"><span class="comment">1. thisArg</span></span><br><span class="line"><span class="comment">    在函数运行时指定的 this 值</span></span><br><span class="line"><span class="comment">    如果指定了 null 或者 undefined 则内部 this 指向 window</span></span><br><span class="line"><span class="comment">2.arg1, arg2, ...</span></span><br><span class="line"><span class="comment">    指定的参数列表</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数。</p><p>  注意：该方法的作用和 <code>call()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是若干个参数的列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>(a+b);</span><br><span class="line">    <span class="built_in">console</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1.call(<span class="literal">null</span>,[<span class="number">100</span>,<span class="number">200</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">1. thisArg</span></span><br><span class="line"><span class="comment">2. argsArray</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>apply()</code> 与 <code>call()</code> 非常相似，不同之处在于提供参数的方式。<br><code>apply()</code> 使用参数数组而不是一组参数列表。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用apply和call改变函数中this的指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"这个函数是window对象的一个方法:"</span>+(x+y)+<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.f1(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//obj是一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">     age:<span class="number">10</span>,</span><br><span class="line">     sex:<span class="string">"男"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.f1.apply(obj,[<span class="number">10</span>,<span class="number">20</span>]);</span><br><span class="line"><span class="built_in">window</span>.f1.call(obj,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(obj);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过apply和call改变原型方法中this的指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型添加方法</span></span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"您好啊:"</span>+<span class="keyword">this</span>.sex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">"男"</span>);</span><br><span class="line">per.sayHi();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"=============="</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"小明"</span>,<span class="string">"人妖"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1=per.sayHi.apply(stu,[<span class="number">10</span>,<span class="number">20</span>]);</span><br><span class="line"><span class="keyword">var</span> r2=per.sayHi.call(stu,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1);</span><br><span class="line"><span class="built_in">console</span>.log(r2);</span><br></pre></td></tr></table></figure><h4 id="apply和call方法的由来"><a href="#apply和call方法的由来" class="headerlink" title="apply和call方法的由来"></a>apply和call方法的由来</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>+<span class="string">":====&gt;调用了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f1是函数,f1也是对象</span></span><br><span class="line"><span class="built_in">console</span>.dir(f1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象调用方法,说明,该对象中有这个方法</span></span><br><span class="line">f1.apply();</span><br><span class="line">f1.call();</span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__==<span class="built_in">Function</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的函数都是Function的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);<span class="comment">//ƒ () &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Function</span>);</span><br><span class="line"><span class="comment">//apply和call方法实际上并不在函数这个实例对象中,而是在Function的prototype中</span></span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>​    bind函数是复制函数，在复制函数的时候改变了this的指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：fun.bind(thisArg,args...)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x+y);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> ff = f1.bind(per,<span class="number">10</span>,<span class="number">20</span>);  <span class="comment">//这边将f1函数复制了一份，同时改变了f1函数中this的指向</span></span><br><span class="line">ff();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.参数：</span></span><br><span class="line"><span class="comment">  1.1 thisArg</span></span><br><span class="line"><span class="comment">      当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</span></span><br><span class="line"><span class="comment">  1.2 arg1, arg2, ...</span></span><br><span class="line"><span class="comment">      当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.返回值：返回由指定的this值和初始化参数改造的原函数拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>示例1：对象方法中this的修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>+<span class="string">"====&gt;"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制了一份</span></span><br><span class="line"><span class="keyword">var</span> ff=per.play.bind(stu);</span><br><span class="line">ff();</span><br></pre></td></tr></table></figure><p>示例2：返回函数中this的修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.x; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 返回 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">// 返回 9, 在这种情况下，"this"指向全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，将"this"绑定到module对象</span></span><br><span class="line"><span class="comment">// 新手可能会被全局的x变量和module里的属性x所迷惑</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">// 返回 81</span></span><br></pre></td></tr></table></figure><p>示例3：定时器函数中this修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ShowRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ShowRandom.prototype.showRandom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//通过bind方法来修改定时器中this指向</span></span><br><span class="line">        <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> num = <span class="keyword">this</span>.produceNum();</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>),<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ShowRandom.prototype.produceNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">10</span>+<span class="number">1</span>);<span class="comment">//1~10的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> ShowRandom();</span><br><span class="line">    s.showRandom();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><p>call 和 apply 特性一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.都是用来调用函数，而且是立即调用</span><br><span class="line">2.但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向</span><br><span class="line">3.call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可</span><br><span class="line">4.apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递</span><br><span class="line">5.如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window</span><br></pre></td></tr></table></figure></li><li><p>bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数</span><br><span class="line">2.它和 call、apply 最大的区别是：bind 不会调用</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-函数</title>
      <link href="/2017/09/11/JavaScript-%E5%87%BD%E6%95%B0/"/>
      <url>/2017/09/11/JavaScript-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ul><li>函数声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>函数表达式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><p>函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。<br>函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 <code>tellStory</code> <code>sayHello</code>等</p></li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ul><li>调用函数的语法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名();</span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><p>函数体只有在调用的时候才会执行，调用需要()进行调用。<br>可以调用多次(重复使用)</p></li></ul><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"吃了没？"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">sayHi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1-100之间所有数的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span>  i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getSum();</span><br></pre></td></tr></table></figure><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul><li>为什么要有参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然上面代码可以重复调用，但是只能计算1-100之间的值</span></span><br><span class="line"><span class="comment">// 如果想要计算n-m之间所有数的和，应该怎么办呢？</span></span><br></pre></td></tr></table></figure><ul><li>语法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部</span></span><br><span class="line"><span class="comment">// 带参数的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的函数调用</span></span><br><span class="line">函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li><p>形参和实参</p><blockquote><ol><li>形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。</li><li>实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。</li></ol></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>, y = <span class="number">6</span>;</span><br><span class="line">fn(x,y); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y</span></span><br></pre></td></tr></table></figure><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><blockquote><p>当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值</p></blockquote><p>返回值语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个带返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过变量来接收这个返回值</span></span><br><span class="line"><span class="keyword">var</span> 变量 = 函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。</p><p>返回值详解：<br>    如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined<br>    如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值<br>    如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined<br>    函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。</p><h2 id="函数其它"><a href="#函数其它" class="headerlink" title="函数其它"></a>函数其它</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>匿名函数：没有名字的函数</p></blockquote><p>匿名函数如何使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将匿名函数赋值给一个变量，这样就可以通过变量进行调用</span><br><span class="line">匿名函数自调用</span><br></pre></td></tr></table></figure><p>关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。</p><h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><blockquote><p>匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">123</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="函数是一种数据类型"><a href="#函数是一种数据类型" class="headerlink" title="函数是一种数据类型"></a>函数是一种数据类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn);</span><br></pre></td></tr></table></figure><ul><li>函数作为参数</li></ul><p>​        因为函数也是一种类型，可以把函数作为两一个函数的参数，在两一个函数中调用</p><ul><li>函数做为返回值</li></ul><p>​        因为函数是一种类型，所以可以把函数可以作为返回值从函数内部返回，这种用法在后面很常见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">15</span>)();</span><br></pre></td></tr></table></figure><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.命名规范  </span><br><span class="line">2.变量规范   </span><br><span class="line">var name = &apos;zs&apos;;</span><br><span class="line">3.注释规范</span><br><span class="line">// 这里是注释</span><br><span class="line">4.空格规范</span><br><span class="line">5.换行规范</span><br><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">if (a &gt; b) &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链(有点复杂啊~)</title>
      <link href="/2017/08/29/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E7%82%B9%E5%A4%8D%E6%9D%82%E5%95%8A/"/>
      <url>/2017/08/29/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E7%82%B9%E5%A4%8D%E6%9D%82%E5%95%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="神奇的原型链"><a href="#神奇的原型链" class="headerlink" title="神奇的原型链"></a>神奇的原型链</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divObj=<span class="built_in">document</span>.getElementById(<span class="string">"dv"</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(divObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//divObj.__proto__----&gt;HTMLDivElement.prototype</span></span><br><span class="line"><span class="comment">//HTMLDivElement.prototype的__proto__---&gt;HTMLElement.prototype</span></span><br><span class="line"><span class="comment">//HTMLElement.prototype的__proto__----&gt;Element.prototype</span></span><br><span class="line"><span class="comment">//Element.prototype的__proto__----&gt;Node.prototype</span></span><br><span class="line"><span class="comment">//Node.prototype的__proto__----&gt;EventTarget.prototype</span></span><br><span class="line"><span class="comment">//EventTarget.prototype的__proto__----&gt;Object.prototype</span></span><br><span class="line"><span class="comment">//Object.prototype中的__proto__是null</span></span><br></pre></td></tr></table></figure><h3 id="原型链详解"><a href="#原型链详解" class="headerlink" title="原型链详解"></a>原型链详解</h3><p>​    构造函数的原型属性(prototype)中，除了拥有构造方法constructor之外，还有一个<strong> proto </strong>属性，该属性指向父亲的原型对象(prototype)。</p><p>​    对象的<strong> proto </strong>属性指向了函数的原型，就构成了原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.dir(per);<span class="comment">//实例对象的结构</span></span><br><span class="line"><span class="built_in">console</span>.dir(Person);<span class="comment">//构造函数的结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例对象中有__proto__原型</span></span><br><span class="line"><span class="comment">//构造函数中有prototype原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prototype是对象</span></span><br><span class="line"><span class="comment">//所以,prototype这个对象中也有__proto__,那么指向了哪里</span></span><br><span class="line"><span class="comment">//实例对象中的__proto__指向的是构造函数的prototype</span></span><br><span class="line"><span class="comment">//所以,prototype这个对象中__proto__指向的应该是某个构造函数的原型prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)   <span class="comment">//nul</span></span><br></pre></td></tr></table></figure><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 面向对象编程思想:根据需求,分析对象,找到对象有什么特征和行为,通过代码的方式来实现需求,要想实现这个需求,就要创建对象,要想创建对象,就应该显示有构造函数,然后通过构造函数来创建对象.,通过对象调用属性和方法来实现相应的功能及需求,即可</span></span><br><span class="line"><span class="comment">   * 首先JS不是一门面向对象的语言,JS是一门基于对象的语言,那么为什么学习js还要学习面向对象,因为面向对象的思想适合于人的想法,编程起来会更加的方便,及后期的维护....</span></span><br><span class="line"><span class="comment">   * 面向对象的编程语言中有类(class)的概念(也是一种特殊的数据类型),但是JS不是面向对象的语言,所以,JS中没有类(class),但是JS可以模拟面向对象的思想编程,JS中会通过构造函数来模拟类的概念(class)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 小明,小红，小丽，小白，小花 都是人</span></span><br><span class="line"><span class="comment">   * 共同的特征和行为</span></span><br><span class="line"><span class="comment">   * 特征---&gt;属性</span></span><br><span class="line"><span class="comment">   * 行为---方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 面向对象的特性:封装,继承,多态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 封装:就是包装</span></span><br><span class="line"><span class="comment">   * 一坨重复代码放在一个函数中--封装</span></span><br><span class="line"><span class="comment">   * 一系列的属性放在一个对象中--封装</span></span><br><span class="line"><span class="comment">   * 一些功能类似的函数(方法)放在一个对象中--封装</span></span><br><span class="line"><span class="comment">   * 好多相类似的对象放在一个js文件中---封装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 继承: 首先继承是一种关系,类(class)与类之间的关系,JS中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承</span></span><br><span class="line"><span class="comment">   * 继承也是为了数据共享,js中的继承也是为了实现数据共享</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 原型作用之一:数据共享,节省内存空间</span></span><br><span class="line"><span class="comment">   * 原型作用之二:为了实现继承</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 继承是一种关系:</span></span><br><span class="line"><span class="comment">   * 父类级别与类级别的关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 例子:</span></span><br><span class="line"><span class="comment">   * 人:  姓名, 性别, 年龄 ,吃饭, 睡觉</span></span><br><span class="line"><span class="comment">   * 学生类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 学习行为</span></span><br><span class="line"><span class="comment">   * 老师类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资,教学行为</span></span><br><span class="line"><span class="comment">   * 程序员: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资, 敲代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 动物类别:  体重， 颜色, 吃</span></span><br><span class="line"><span class="comment">   * 狗类别:   体重,颜色, 吃, 咬人</span></span><br><span class="line"><span class="comment">   * 猫类别: 体重,颜色, 吃, 咬人 逗主人开心,你好帅</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 多态:一个对象有不同的行为,或者是同一个行为针对不同的对象,产生不同的结果,要想有多态,就要先有继承*/</span></span><br></pre></td></tr></table></figure><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承例子:</span></span><br><span class="line"><span class="comment">//人,都有姓名,性别,年龄, 吃饭, 睡觉, 玩</span></span><br><span class="line"><span class="comment">//学生,都有姓名,性别,年龄, 成绩, 吃饭, 睡觉, 玩 ,学习的行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//js中通过原型来实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"人可以吃东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">score</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在改变学生原型对象之前先给学生的原型中添加一个sayHi方法(这个方法会出现什么情况?)</span></span><br><span class="line">Student.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi~~~"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变学生的原型的指向即可==========&gt;学生和人已经发生关系</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相同的代码太多,造成了代码的冗余(重复的代码)</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.age);</span><br><span class="line">stu.eat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"下面的是学生对象中自己有的"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.score);</span><br><span class="line">stu.sayHi();<span class="comment">//错误?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般步骤是：先修改函数原型，再向修改后的原型中添加信息</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承案例</span></span><br><span class="line"><span class="comment">//动物有名字,有体重,有吃东西的行为</span></span><br><span class="line"><span class="comment">//小狗有名字,有体重,有毛色, 有吃东西的行为,还有咬人的行为</span></span><br><span class="line"><span class="comment">//哈士奇名字,有体重,有毛色,性别, 有吃东西的行为,还有咬人的行为,逗主人开心的行为</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name,weight</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.weight=weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动物的原型的方法</span></span><br><span class="line">Animal.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"天天吃东西,就是吃"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//狗的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype=<span class="keyword">new</span> Animal(<span class="string">"哮天犬"</span>,<span class="string">"50kg"</span>);</span><br><span class="line">Dog.prototype.bitePerson=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哼~汪汪~咬死你"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈士奇</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErHa</span>(<span class="params">sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">ErHa.prototype=<span class="keyword">new</span> Dog(<span class="string">"黑白色"</span>);</span><br><span class="line">ErHa.prototype.playHost=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哈哈~要坏衣服,要坏桌子,拆家..嘎嘎...好玩,开心不,惊喜不,意外不"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> erHa=<span class="keyword">new</span> ErHa(<span class="string">"雄性"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(erHa.name,erHa.weight,erHa.color);</span><br><span class="line">erHa.eat();</span><br><span class="line">erHa.bitePerson();</span><br><span class="line">erHa.playHost();</span><br></pre></td></tr></table></figure><h3 id="构造函数的属性继承"><a href="#构造函数的属性继承" class="headerlink" title="构造函数的属性继承"></a>构造函数的属性继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面原型继承中为了数据共享,改变原型指向,做到了继承  ---通过改变原型指向实现的继承</span></span><br><span class="line"><span class="comment">//缺陷:因为改变原型指向的同时实现继承,直接初始化了属性，继承过来的属性的值都是一样的了,所以,这就是问题只能重新调用对象的属性进行重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方案:继承的时候,不用改变原型的指向,直接调用父级的构造函数的方式来为属性赋值就可以了  ------借用构造函数:把要继承的父级的构造函数拿过来,使用一下就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数继承属性成员</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Student(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.type, s1.name, s1.age) <span class="comment">// =&gt; human 张三 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//借用构造函数:构造函数名字.call(当前对象,属性,属性,属性....);</span></span><br><span class="line"><span class="comment">//解决了属性继承,并且值不重复的问题</span></span><br><span class="line"><span class="comment">//缺陷:父级类别中的方法不能继承</span></span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合继承:原型继承+借用构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"阿涅哈斯诶呦"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex,score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//借用构造函数:属性值重复的问题</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,age,sex);</span><br><span class="line">    <span class="keyword">this</span>.score=score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变原型指向----继承</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person();<span class="comment">//不传值</span></span><br><span class="line">Student.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的"小黑",20,"男","100分" 都是属于对象的信息，不是原型的信息</span></span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"小黑"</span>,<span class="number">20</span>,<span class="string">"男"</span>,<span class="string">"100分"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.name,stu.age,stu.sex,stu.score);</span><br><span class="line">stu.sayHi();</span><br><span class="line">stu.eat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu2=<span class="keyword">new</span> Student(<span class="string">"小黑黑"</span>,<span class="number">200</span>,<span class="string">"男人"</span>,<span class="string">"1010分"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu2.name,stu2.age,stu2.sex,stu2.score);</span><br><span class="line">stu2.sayHi();</span><br><span class="line">stu2.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性和方法都被继承了</span></span><br><span class="line"><span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><h3 id="构造函数的属性继承-拷贝继承"><a href="#构造函数的属性继承-拷贝继承" class="headerlink" title="构造函数的属性继承+拷贝继承"></a>构造函数的属性继承+拷贝继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象拷贝继承原型对象成员</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> Person.prototype) &#123;</span><br><span class="line">  Student.prototype[key] = Person.prototype[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Student(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">s1.sayName() <span class="comment">// =&gt; hello 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//效率较低，内存占用高（因为要拷贝父类的属性）</span></span><br><span class="line"><span class="comment">//无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</span></span><br><span class="line"><span class="comment">//不推荐使用</span></span><br></pre></td></tr></table></figure><h3 id="逆推继承看原型"><a href="#逆推继承看原型" class="headerlink" title="逆推继承看原型"></a>逆推继承看原型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F2</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F2.prototype = <span class="keyword">new</span> F1(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">F3.prototype = <span class="keyword">new</span> F2(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> F3(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f3.age);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="属性成员的搜索原则"><a href="#属性成员的搜索原则" class="headerlink" title="属性成员的搜索原则"></a>属性成员的搜索原则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当实例对象和原型中都有sex信息的时候，访问对象的属性获取的是谁的信息呢？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex=<span class="string">"女"</span>;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">"男"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per.sex);</span><br></pre></td></tr></table></figure><p>​    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 搜索首先从对象实例本身开始</span><br><span class="line">2. 如果在实例中找到了具有给定名字的属性，则返回该属性的值</span><br><span class="line">3. 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</span><br><span class="line">4. 如果在原型对象中找到了这个属性，则返回该属性的值</span><br><span class="line">5. 如果在原型对象中没有找到这个属性，则继续从父亲的原型中查找，有就返回</span><br></pre></td></tr></table></figure><p>​    也就是说，在我们调用   <code>per.sex</code> 的时候，会先后执行两次搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 首先，解析器会问：“实例 per 有 sex 属性吗？”答：“没有。</span><br><span class="line"><span class="number">2.</span> 然后，它继续搜索，再问：“ per 的原型有 sex 属性吗？”答：“没有。</span><br><span class="line"><span class="number">3.</span> 于是，它就从父亲的原型中查找有没有sex</span><br></pre></td></tr></table></figure><p>​    而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">1. 先在自己身上找，找到即返回</span><br><span class="line">2. 自己身上找不到，则沿着原型链向上查找，找到即返回</span><br><span class="line">3. 如果一直到原型链的末端还没有找到，则返回 undefined</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>元素的定位属性</title>
      <link href="/2017/08/15/%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/08/15/%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="元素的定位属性"><a href="#元素的定位属性" class="headerlink" title="元素的定位属性"></a>元素的定位属性</h2><p>元素的定位属性主要包括定位模式和边偏移两部分,只有定位了的盒子才可以使用这些属性</p><p>1、边偏移</p><a id="more"></a><table><thead><tr><th>边偏移属性</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>顶端偏移量，定义元素相对于其父元素上边线的距离</td></tr><tr><td>bottom</td><td>底部偏移量，定义元素相对于其父元素下边线的距离</td></tr><tr><td>left</td><td>左侧偏移量，定义元素相对于其父元素左边线的距离</td></tr><tr><td>right</td><td>右侧偏移量，定义元素相对于其父元素右边线的距离</td></tr></tbody></table><p>也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px;  left: 30px; 等等</p><p>2、定位模式(定位的分类)</p><p>在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：</p><p>选择器{position:属性值;}</p><p>position属性的常用值</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>static</td><td>自动定位（默认定位方式）</td></tr><tr><td>relative</td><td>相对定位，相对于其原文档流的位置进行定位</td></tr><tr><td>absolute</td><td>绝对定位，相对于其上一个已经定位的父元素进行定位</td></tr><tr><td>fixed</td><td>固定定位，相对于浏览器窗口进行定位</td></tr></tbody></table><h2 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位(static)"></a>静态定位(static)</h2><p>静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。</p><p>上面的话翻译成白话：  就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。</p><p>在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。</p><p>PS： 静态定位其实没啥可说的。</p><h2 id="相对定位relative"><a href="#相对定位relative" class="headerlink" title="相对定位relative"></a>相对定位relative</h2><p>相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。</p><p>对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留</p><p>注意：   </p><ol><li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。</li><li>其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）</li></ol><p>就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）</p><p>如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。</p><h2 id="绝对定位absolute"><a href="#绝对定位absolute" class="headerlink" title="绝对定位absolute"></a>绝对定位absolute</h2><p>[注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。</p><p>当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。</p><p>注意：    绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。</p><h3 id="父级没有定位"><a href="#父级没有定位" class="headerlink" title="父级没有定位"></a>父级没有定位</h3><p>若所有父元素都没有定位，以浏览器为准对齐(document文档)。</p><h3 id="父级有定位"><a href="#父级有定位" class="headerlink" title="父级有定位"></a>父级有定位</h3><p>绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 </p><h3 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h3><p>这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。这句话的意思是 子级是绝对定位的话， 父级要用相对定位。</p><p>首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。</p><p>就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。</p><p>所以，我们可以得出如下结论：</p><p>因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。</p><p>父盒子布局时，需要占有位置，因此父亲只能是 相对定位. </p><p>这就是子绝父相的由来。</p><h2 id="绝对定位的盒子水平-垂直居中"><a href="#绝对定位的盒子水平-垂直居中" class="headerlink" title="绝对定位的盒子水平/垂直居中"></a>绝对定位的盒子水平/垂直居中</h2><p>普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了</p><p>定位的盒子也可以水平或者垂直居中，有一个算法。</p><ol><li>首先left 50%   父盒子的一半大小</li><li>然后走自己外边距负的一半值就可以了 margin-left。</li></ol><h2 id="固定定位fixed"><a href="#固定定位fixed" class="headerlink" title="固定定位fixed"></a>固定定位fixed</h2><p>固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。</p><p>当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。</p><p>固定定位有两点：</p><ol><li>固定定位的元素跟父亲没有任何关系，只认浏览器。</li><li>固定定位完全脱标，不占有位置，不随着滚动条滚动。。</li></ol><p>ie6等低版本浏览器不支持固定定位。</p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。</p><p>在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。</p><p>比如：  z-index: 2;</p><p>注意：</p><ol><li><p>z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。</p></li><li><p>如果取值相同，则根据书写顺序，后来居上。</p></li><li><p>后面数字一定不能加单位。</p></li><li><p>只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。</p><p>​</p><p>​</p><p><strong>四种定位总结</strong></p></li></ol><table><thead><tr><th>定位模式</th><th>是否脱标占有位置</th><th>是否可以使用边偏移</th><th>移动位置基准</th></tr></thead><tbody><tr><td>静态static</td><td>不脱标，正常模式</td><td>不可以</td><td>正常模式</td></tr><tr><td>相对定位relative</td><td>不脱标，占有位置</td><td>可以</td><td>相对自身位置移动（自恋型）</td></tr><tr><td>绝对定位absolute</td><td>完全脱标，不占有位置</td><td>可以</td><td>相对于定位父级移动位置（拼爹型）</td></tr><tr><td>固定定位fixed</td><td>完全脱标，不占有位置</td><td>可以</td><td>相对于浏览器移动位置（认死理型）</td></tr></tbody></table><h1 id="定位模式转换"><a href="#定位模式转换" class="headerlink" title="定位模式转换"></a>定位模式转换</h1><p>跟浮动一样， 元素添加了绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为行内块模式，</p><p>因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。</p><h1 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h1><p>在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。</p><p>他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！</p><h2 id="display-显示"><a href="#display-显示" class="headerlink" title="display 显示"></a>display 显示</h2><p>display 设置或检索对象是否及如何显示。</p><p>display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。</p><p>特点： 隐藏之后，不再保留位置。</p><h2 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h2><p>设置或检索是否显示对象。</p><p>visible : 　对象可视</p><p>hidden : 　对象隐藏</p><p>特点： 隐藏之后，继续保留原有位置</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo和git建立博客</title>
      <link href="/2017/07/01/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgit%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/07/01/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgit%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h2><h4 id="1-搭建Node-js环境"><a href="#1-搭建Node-js环境" class="headerlink" title="1.搭建Node.js环境"></a><strong>1.搭建Node.js环境</strong></h4><p>搭建博客网站首先需要安装Node.js环境。</p><p>下载地址：<a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a> </p><p>测试安装：命令行使用node -v 、npm -v，查看显示版本号即成功。</p><a id="more"></a><h4 id="2-安装Hexo博客框架工具"><a href="#2-安装Hexo博客框架工具" class="headerlink" title="2. 安装Hexo博客框架工具"></a>2. <strong>安装Hexo博客框架工具</strong></h4><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在</p><p>控制台下（cmd）使用如下命令：</p><p>npm install hexo-cli -g</p><h4 id="3-安装Git版本工具"><a href="#3-安装Git版本工具" class="headerlink" title="3.安装Git版本工具"></a><strong>3.安装Git版本工具</strong></h4><h4 id="Git是目前世界上最流行的分布式版本控制系统"><a href="#Git是目前世界上最流行的分布式版本控制系统" class="headerlink" title="Git是目前世界上最流行的分布式版本控制系统"></a>Git是目前世界上最流行的分布式版本控制系统</h4><h4 id="使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。"><a href="#使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。" class="headerlink" title="使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。"></a>使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。</h4><h4 id="下载地址：https-git-scm-com-downloads"><a href="#下载地址：https-git-scm-com-downloads" class="headerlink" title="下载地址：https://git-scm.com/downloads"></a>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></h4><p><em>测试安装:右击鼠标，如果有git bash等两个选项 即安装成功。</em></p><h4 id="4-注册Github账号"><a href="#4-注册Github账号" class="headerlink" title="4.注册Github账号"></a><strong>4.注册Github账号</strong></h4><p> gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式</p><p>进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。 </p><p>注册地址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a>  </p><h2 id="二、开始搭建博客"><a href="#二、开始搭建博客" class="headerlink" title="二、开始搭建博客"></a>二、<strong>开始搭建博客</strong></h2><h4 id="1-开启GitHub服务"><a href="#1-开启GitHub服务" class="headerlink" title="1. 开启GitHub服务"></a>1. <strong>开启GitHub服务</strong></h4><p> 通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/1.png" alt="img"></p><p>新仓库的名字，最好是是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<a href="https://UserName.github.io的形式。" target="_blank" rel="noopener">https://UserName.github.io的形式。</a> </p><p>注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很长</p><p>点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/2.png" alt="img"></p><p>这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/3.png" alt="img"></p><p>再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/4.png" alt="img"></p><p>现在，可以使用<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">https://UserName.github.io</a>，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然点丑)：</p><p><img src="/2017/07/01/使用hexo和git建立博客/5.png" alt="img"></p><h4 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2.创建本地博客站点"></a><strong>2.创建本地博客站点</strong></h4><p>上述的步骤相当于我们使用Github，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很丑。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台(cmd)命令在本地一个合适的位置创建博客站点文件夹如下：</p><p><strong>hexo init myHexoBlog</strong> <strong>//myHexoBlog是项目名</strong></p><p><img src="/2017/07/01/使用hexo和git建立博客/6.png" alt="img"></p><p>测试本地博客站点，在本地博客根目录(git bash)下使用控制台命令：</p><p>hexo g <em>//g是generetor的缩写，生成博客</em> </p><p>hexo s <em>//s是server的缩写，启动服务</em></p><p>此时打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，我们将会看到Hexo自带默认主题显示的博客样式如下:</p><p><img src="/2017/07/01/使用hexo和git建立博客/7.png" alt="img"></p><h4 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3.同步Github,允许公共访问"></a><strong>3.同步Github,允许公共访问</strong></h4><p> 初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are.</p><p><img src="/2017/07/01/使用hexo和git建立博客/8.png" alt="img"></p><p>你需要运行命令来配置你的用户名和邮箱：</p><p>$ git config –global user.name “xx”</p><p>$ git config –global user.email “<a href="mailto:xxx@xx.com" target="_blank" rel="noopener">xxx@xx.com</a>“</p><p><strong>注意：（引号内请输入你自己设置的名字，和你自己的邮箱）</strong>此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱</p><h3 id="git配置SSH-Key"><a href="#git配置SSH-Key" class="headerlink" title="git配置SSH Key"></a><strong>git配置SSH Key</strong></h3><p>1、 打开git bash.exe</p><p>2、检查是否已经有SSH Key  $ cd ~/.ssh</p><p>3、生成SSH Key  $  ssh-keygen -t rsa -C “youremail”</p><p>第一次生成的话，直接一路回车，不需要输入密码。不是第一次生成的话，会提示 overwrite (y/n)? 问你是否覆盖旧的 SSH Key ，直接填 y ，然后一直回车就行了，最后得到了两个文件：id_rsa和id_rsa.pub。<br><img src="/2017/07/01/使用hexo和git建立博客/9.png" alt="img"></p><p>4、记事本打开/C/Users/Administrator/.ssh/下id_rsa.pub文件，复制该段信息；登录github账户，点击头像进入Settings -&gt; SSH and GPG keys -&gt; New SSH key，将复制的信息粘贴到该处。<br><img src="/2017/07/01/使用hexo和git建立博客/10.png" alt="img"></p><p>5、测试是否成功$ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><p>提示“Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.”说明添加成功。</p><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。首先找到我们的博客仓库，并拷贝仓库地址：<img src="/2017/07/01/使用hexo和git建立博客/11.png" alt="img"></p><p>然后修改本地博客目录的配置：<br>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/12.png" alt="img"></p><p>之后执行控制台命令(cmd)：</p><p>npm install hexo-deployer-git <em>//安装部署插件</em></p><p> hexo d <em>//部署到github</em></p><p>再次访问链接：<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">https://userName.github.io</a>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p><h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、<strong>发布博客</strong></h2><p>  可以发布自己的第一篇博客了。来尝试一下以下的步骤：<br>在本地博客文件夹根目录(git bash)输入：</p><p>hexo new “我个人博客的第一篇博客” </p><p>hexo g <em>//生成网页</em> </p><p>hexo d <em>//部署到远端(github)</em></p><p><img src="/2017/07/01/使用hexo和git建立博客/13.png" alt="img"></p><p>现在打开我们的博客网站：<a href="http://username.github.io/" target="_blank" rel="noopener">http://UserName.github.io</a>,会看到网页</p><p>（显示可能有延迟 所以可以采用以下方法(git bash)：</p><p> hexo clean <em>//清理缓存</em> </p><p>hexo g <em>//重新生成博客代码</em> </p><p>hexo d <em>//部署到本地</em></p><p><em>稍等即可</em></p><p><em>顺便一提</em> <em>hexo s</em> <em>启动本地服务器，用于预览</em></p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a><strong>四、更换主题</strong></h2><p> 为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主</p><p>题下自己编写美化博客界面）。这里以使用github上的next主题为例：</p><h4 id="1-创建next文件夹"><a href="#1-创建next文件夹" class="headerlink" title="1.创建next文件夹"></a><strong>1.创建next文件夹</strong></h4><p>切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题(git bash)</p><p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><p><em>//下载主题</em></p><p>下载成之后我们会看到next的主题已经存在thems里了如下：</p><p><img src="/2017/07/01/使用hexo和git建立博客/14.png" alt="img"></p><h4 id="3-修改博客配置文件，更换主题配置"><a href="#3-修改博客配置文件，更换主题配置" class="headerlink" title="3.修改博客配置文件，更换主题配置"></a><strong>3.修改博客配置文件，更换主题配置</strong></h4><p>修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next</p><p><img src="/2017/07/01/使用hexo和git建立博客/15.png" alt="img"></p><p>然后在控制台（git bash）下输入如下命令：</p><p>hexo clean <em>//清理缓存</em></p><p> hexo g <em>//重新生成博客代码</em> </p><p>hexo d <em>//部署到本地</em></p><p>再次打开我们的博客网站<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">https://UserName.github.io</a>，将会看到更换主题后</p><p>更多主题美化：</p><p><a href="https://blog.csdn.net/qq_32454537/article/details/79482896" target="_blank" rel="noopener">https://blog.csdn.net/qq_32454537/article/details/79482896</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 小白 git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
